---
output: word_document
editor_options: 
  chunk_output_type: console
---

```{r, prep-data,echo=F, message=F, warning=F, fig.width=6, fig.height=4,include=F,message=F}

if(load.results==F)
{
  Stocks <- ASR.long |> 
                      collapse::fsubset(!is.na(value)) |>
                      collapse::fgroup_by(Stock, type) |>
                      collapse::fsummarize(count=length(unique(value))) |>
                      collapse::fgroup_by(Stock) |>
                      collapse::fsummarize(types=length(unique(type))) |>
                      collapse::fsubset(types==5) |>
                      collapse::fselect(Stock)

  ASR.tmp <- ASR.long 
  ASR.tmp$age <- as.numeric(ASR.tmp$age)
  ASR.stocks <- ASR.tmp |> 
                          collapse::fsubset(Stock %in% Stocks$Stock) |>
                          collapse::fsubset(!is.na(value)) |>
                          collapse::roworder(Stock, Year, type, age)
                          
  # print(Stocks)
  Stocks <- Stocks$Stock
  
  # Going to remove Sebastes norvegicus because we can't get fecundity as the only data we have is total numbers.
  #Stocks <- Stocks[Stocks != "ICES-AFWG_DEEP1-2_Sebastes_norvegicus"]
  # Esmarki doesn't work great as it is assessed using a quarterly model.
  #Stocks <- Stocks[Stocks != "ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii"]
  #i = 'ICES-AFWG_NEA1-2_Melanogrammus_aeglefinus'
  years.tmp <- NULL
  pnm.tmp <- NULL
  waa.tmp <- NULL
  ages.tmp <- NULL
  rem.tmp <- NULL
  mx.tmp <- NULL
  NE.tmp <- NULL
  vpa.tmp <- NULL
  am.tmp <- NULL
  #mr.tmp <- NULL
  abund.tmp <- NULL
  full.abund.tmp <- NULL
  full.rem.tmp <- NULL
  fs.tmp <- NULL
  for(i in Stocks)
  {
  print(i)
  ASR.sub <- ASR.long |>
    collapse::fselect(Year, Stock, type, age, value) |>
    collapse::fsubset(Stock==i)

  
    # Dropping the first 7 years as the 8 year olds are all missing
  if(i == "ICES-WGNSSK_NS  4-6a-20_Melanogrammus_aeglefinus") ASR.sub <- ASR.sub |> collapse::fsubset(Year >= 1972)
  # maxage <- max(as.numeric(ASR.sub$age[!is.na(ASR.sub$value)]))
  # maxYear <- max(ASR.sub$Year[!is.na(ASR.sub$value)])
  # minYear <- min(ASR.sub$Year[!is.na(ASR.sub$value)])
  # forplot <- ASR.sub[as.numeric(ASR.sub$age) < (maxage+1) & ASR.sub$Year %in% minYear:maxYear,]
  # 
  # # summary plots
  # print(ggplot() + geom_line(data=forplot, aes(Year, value)) + facet_grid(type~as.numeric(age), scales="free_y") +
  #         geom_vline(data=forplot[is.na(forplot$value),], aes(xintercept=Year), colour="red") + facet_grid(type~as.numeric(age), scales="free_y") +
  #         theme_bw() + 
  #         ggtitle(i)
  # )
  
  age.mat <- ASR.sub |> collapse::fsubset(type=="AM") |> dplyr::rename(AM=value) |> collapse::fselect(-type)
  # All of the age at maturities are NA in 0 and 1 year olds, so make them 0's, do that carefully just
  # in case that changes later...
  am.0s <- length(which((!is.na(age.mat$AM[age.mat$age ==0]))))
  am.1s <- length(which((!is.na(age.mat$AM[age.mat$age ==1]))))
  am.2s <- length(which((!is.na(age.mat$AM[age.mat$age ==2]))))
  if(am.0s == 0) age.mat$AM[age.mat$age ==0] <- 0
  if(am.1s == 0) age.mat$AM[age.mat$age ==1] <- 0
  if(am.2s == 0) age.mat$AM[age.mat$age ==2] <- 0
  
  #if(am.1s | am.0s | am.2s > 0) print("Stop, you need to check the age at maturity for either age 0 or 1 as there is data in there.")
  nat.mort <-  ASR.sub |> collapse::fsubset(type=="NM") |> dplyr::rename(NM=value) |> collapse::fselect(-type)
  abund <- ASR.sub |> collapse::fsubset(type=="Num") |> dplyr::rename(Num=value) |> collapse::fselect(-type)
  weight.age <- ASR.sub |> collapse::fsubset(type=="WA") |> dplyr::rename(WA=value) |> collapse::fselect(-type)
  if(i == Stocks[30]) weight.age$WA <- weight.age$WA/1000
  removals <- ASR.sub |> collapse::fsubset(type=="Catch") |> dplyr::rename(Catch=value) |> collapse::fselect(-type)

  data <- age.mat |>
    full_join(nat.mort) |>
    full_join(abund) |>
    full_join(weight.age) |>
    full_join(removals)

  # Aahh??  Is this NA dropping useful data, needed to quick fix the age at maturity data...
  data$available <- apply(is.na(data[, c("AM", "Num", "WA")]), 1, function(x) all(!x==T))
  data <- data[data$available==T,]

  # Tidy up the data for input...
  data$prop.nat.mort <- 1-exp(-data$NM)
  #prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))] <- 1-exp(-prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))])

  
  rem <- data |> collapse::fgroup_by(Year) |> collapse::fsummarize(rem=sum(Catch,na.rm=T)) #|> dplyr::pull(rem)
  #rem <- data |> dplyr::group_by(Year,.drop=F) |> collapse::fsummarize(rem=sum(Catch,na.rm=T)) #|> dplyr::pull(rem)
  
  # Never run, so not doing anything.
  # missing_rem<- NULL
  # if(any(is.na(rem$rem))) 
  # {
  #   missing_rem <- unique(data$Year)[which(is.na(rem$rem))]
  #   rem$rem[is.na(rem$rem)] <- median(rem$rem, na.rm=T)
  # }
  
  #rowSums(removals[,-which(names(removals) %in% c("Year", "Stock", "type"))], na.rm=T)
  years <- data |> dplyr::pull(Year) |> unique() |> sort()
  
  N.end <- sum(data[data$Year==max(years),]$Num)
  vpa.abund <- data |> dplyr::group_by(Year) |> dplyr::summarize(vpa=sum(Num,na.rm=T)) |> pull(vpa)

  # The real mx matrix, recruits produced per individual in each age class... Not perfect as I need to offset recruits/ssb, but close enough for the moment..
  #minage
  minage <- min(as.numeric(data$age))
  #maxage
  maxage <- max(as.numeric(data$age))
  #recruits
  annual <- data.frame(Year=data$Year[data$age==minage], recruits=data$Num[data$age==minage])
  #ssn
  data$ssn <- data$Num * data$AM
  #ssb
  data$ssb <- data$ssn * data$WA #I need to figure out how to line this up with the number of recruits for the right years in the data object.... got it right for the overall r.p.ssb below.
  #tot.ssb
  annual <- data |> group_by(Year) |> summarize(tot.ssb = sum(ssb)) |> left_join(annual)
  
  #tst <- data |> group_by(Year) |> summarize(tot.ssn = sum(ssn)) |> left_join(annual)

  #r.p.ssb This needs to be offset by the age of recruits. So here's my lining this up logic.  For age 0, we get
  # the recruit and SSB estimates from the same survey, thus these age 0 recruits will have been produced by the SSB in the previous year...
  # So the R in 1970 were produced by SSB in 1969 when min age =0
  # If min.age = 1 then R in 1970 is produced by SSB in 1968... and so on.
  # FIX 1 "Recruit year" = SSB year + min.age + 1 (or min.age +2 as SSB.year is the first column)
  # Now for RPS there's another wrinkle because of this, because our model is N(1970) = lambda * N(1969) and lambda is made up of lx and mx
  # so if the recruits show up in 1970, the fecundity term that gets us there (irrespective of the age offset) has to be for 1969, becuase
  # that gets us to the babies that show up in 1970
  # FIX 2 So "RPS year, recs.per.age year, and mx year" = SSB year + min.age
  # I believe this to be correct, but we all need to discuss this to make sure the logic holds.
  annual$r.p.ssb <- c(rep(NA,minage),annual$recruits[(minage+2):nrow(annual)]/annual$tot.ssb[1:(nrow(annual)-minage-1)],NA)
  # recs.per.age
  data <- left_join(data, annual)
  # So I need to make an offset SSB in the 'data' object to line up with the correct r.p.ssb field.  This is probably gonna suck...
  tmp <- NULL
  for(j in 1:length(years))
  {
    tst <- data|> collapse::fsubset(Year == years[j]) |> collapse::fselect(ssb,ssn,Year,age)
    tst$Year <- tst$Year + minage # We want this to line up the the RPS year, so just adding minage here.
    names(tst) <- c("ssb.offset","ssn.offset","Year","age")
    tmp[[j]] <- tst
  }
  # Unpack the list
  ssb.off <- do.call('rbind',tmp)
  # And merge it with the data object
  data <- left_join(data,ssb.off,by=c("Year","age"))
  data$recs.per.age <- data$ssb.offset*data$r.p.ssb
  # mx
  # Some of the stocks are just the males and females, so these are already half the population.  Probably can just not include the male stocks in the end.
  # No longer dividing by 2 because we should really divide recruits and ssn by 2 to be female only, but that's pointless so we roll along with this.
  data$mx <- data$recs.per.age/data$ssn.offset # if(grepl("males",i)) 
  #if(!grepl("males",i))data$mx <- data$recs.per.age/data$ssn.offset/2 # Moms only! 
  data$mx[is.nan(data$mx)] <- 0 # if we don't have any spawners in an age class in a year their fecundity is 0
  # Easier to remove the years where we don't have recs.per.age...
  #data <- data |> collapse::fsubset(Year %in% years[(minage+1):length(years)])
  
  age.mat <- data |> collapse::fselect("Year", "age", "AM") |> 
                     pivot_wider(names_from=age, values_from = AM) |> collapse::fselect(-Year)
  prop.nat.mort <- data |> collapse::fselect("Year", "age", "prop.nat.mort") |> 
                            pivot_wider(names_from=age, values_from = prop.nat.mort) |> 
                            collapse::fselect(-Year) |> as.data.frame()
  
  weight.age <- data |> collapse::fselect("Year", "age", "WA") |> pivot_wider(names_from=age, values_from = WA) |> collapse::fselect(-Year)
  mx <- data |> collapse::fselect("Year", "age", "mx") |> 
                 pivot_wider(names_from=age, values_from = mx) |> 
                 collapse::fselect(-Year) |> as.data.frame()
  # Get the abundance matrix
  abund.age <- data |> collapse::fselect("Year", "age", "Num") |> 
                        pivot_wider(names_from=age, values_from = Num) |> 
                        collapse::fselect(-Year) |> as.data.frame()
  
  # Now we can save out the catch and get an instantaneous F
    data$Catch[is.na(data$Catch)] <- 0
    data$Exp <- data$Catch/data$Num 
    # If it is exactly 1 that leads to an Inf, which is annoying, so make it 1.1 and fix it with the rest below
    data$Exp[data$Exp == 1] <- 1.1
    # And make this an F
    data$Fs <- -log(1-data$Exp)
    if(any(is.na(data$Fs)))
    {
      fixers <- which(is.na(data$Fs))
      print(paste0("Had to replace ",length(fixers), ' exploitation rates for stock ',i))
      for(f in fixers)
      {
        yr <- data$Year[f]
        fs <- max(data$Fs[data$Year == yr],na.rm=T)
        data$Fs[f] <- fs
        data$Exp[f] <- 1-exp(-fs)
      }
    }
  
  full.rems <- data |> collapse::fselect("Year", "age", "Catch") |> pivot_wider(names_from=age, values_from = Catch) |> collapse::fselect(-Year)
  full.Fs <-  data |> collapse::fselect("Year", "age", "Fs") |> pivot_wider(names_from=age, values_from = Fs) |> collapse::fselect(-Year)
    
    
    if(i == "DFO_2J3KL_Gadus_morhua")
    {
      age.mat[,8:10] <- 1
      prop.nat.mort[,8:10] <- prop.nat.mort[,7]
      weight.age[12:14,9:10] <- weight.age[12:14,8]
      weight.age[15,10] <- weight.age[15,9]
      mx[12:16,9:10] <- mx[12:16,8]
      mx[17,10] <- mx[17,9]
      full.Fs[12:14,9:10] <- full.Fs[12:14,8]
      full.Fs[15,10] <- full.Fs[15,9]
      abund.age[12:14,9:10] <- abund.age[12:14,8]
      abund.age[15,10] <- abund.age[15,9]
      # I could calculate, but this will get us to the same place...
      full.rems[12:14,9:10] <- full.rems[12:14,8]
      full.rems[15,10] <- full.rems[15,9]
    }
    
    if(i == "DFO_4T-Spring_Clupea_harengus")
    {
      age.mat[6:7,10] <- 1
      prop.nat.mort[6:7,10] <- prop.nat.mort[6:7,9]
      weight.age[6:7,10] <- weight.age[6:7,9]
      mx[6:9,10] <- mx[6:9,9]
      full.Fs[6:7,10] <- full.Fs[6:7,9]
      abund.age[6:7,10] <- abund.age[6:7,9]
      full.rems[6:7,10] <- full.rems[6:7,9]
    }
    
    if(i == "ICES-HAWG_CS 6a- 7b-7c_Clupea_harengus") 
    {
      age.mat[30,8] <- 1
      prop.nat.mort[30,8] <- prop.nat.mort[30,7]
      weight.age[30,8] <- weight.age[29,8]
      mx[30:31,8] <- mx[30:31,9]
      full.Fs[30,8] <- full.Fs[30,7]
      abund.age[30,8] <- abund.age[30,7]
      full.rems[30,8] <- full.rems[30,7]
    }
    
    if(i == "ICES-WGCSE_IS6a-7b-7j_Dicentrarchus _labrax")
    {
      age.mat[c(14,27,40),5] <- age.mat[1,5]
      prop.nat.mort[c(14,27,40),5] <- prop.nat.mort[1,5]
      weight.age[c(14,27,40),5] <- weight.age[c(13,26,39),5]
      mx[c(14,16,27,29,40,42),5] <- mx[c(14,16,27,29,40,42),6]
      full.Fs[c(14,27,40),5] <- full.Fs[c(14,27,40),4]
      abund.age[c(14,27,40),5] <- abund.age[c(14,27,40),4]
      full.rems[c(14,27,40),5] <- full.rems[c(14,27,40),4]
    }
    # Clear out some 0's...
    if( i == "AFSC_EEBSAI_Limanda_aspera")
    {
      mx[5,18] <- mean(unlist(mx[5,c(17,19)]))
      mx[c(6,8),19] <- mx[c(6,8),18]
      mx[2:7,20] <- mx[2:7,19] 
    }
  

  
  # I had filled the years with no SSB data to inform them.  instead I'm going to remove those years...
  
  
   if(minage >0) 
  {
    rm <- -(1:minage)
    years <- years[rm]
    prop.nat.mort <- prop.nat.mort[rm,]
    weight.age <- weight.age[rm,]
    rem <- rem[rm,]
    mx <- mx[rm,]
    vpa.abund <- vpa.abund[rm]
    age.mat <- age.mat[rm,]
    abund.age <- abund.age[rm,]
    full.Fs <- full.Fs[rm,]
    full.rems <- full.rems[rm,]
   }
  #   mx.fill <- as.data.frame(matrix(rep(colMeans(mx,na.rm=T),minage),nrow=minage,byrow=T),colnames = names(mx))
  #   names(mx) <- names(mx.fill)
  #  # mx <- rbind(mx[(minage+1):nrow(mx),],mx.fill) # or is it
  #   mx <- rbind(mx.fill,mx[(minage+1):nrow(mx),]) # I think this is right!
  # }
  
  
    years.tmp[[i]] <- years
    pnm.tmp[[i]] <- prop.nat.mort
    waa.tmp[[i]] <- weight.age
    ages.tmp[[i]] <- minage:maxage
    rem.tmp[[i]] <- rem
    mx.tmp[[i]] <- mx
    NE.tmp[[i]] <- N.end
    vpa.tmp[[i]] <- vpa.abund
    am.tmp[[i]] <- age.mat
    #mr.tmp[[i]] <- missing_rem
    abund.tmp[[i]] <- abund.age
    fs.tmp[[i]] <- full.Fs
    full.rem.tmp[[i]] <- full.rems
  } #end input data loop
  
  save(years.tmp,pnm.tmp,waa.tmp,ages.tmp,rem.tmp,mx.tmp,NE.tmp,vpa.tmp,#mr.tmp,
       am.tmp,Stocks,ASR.stocks,ASR.long,abund.tmp,fs.tmp,full.rem.tmp,
       file =  paste0(loc,"/Results/model_inputs_no_age_correction.Rdata"))
  
  } # end load results
```
  
   
  So now I can try to do some tuning, both forwards and backwards, lets see what we get from that...
  
```{r tunes,include=F,echo=F,warning=F,message=F}
  
  
  ########################## Now run the tuning sims
  #
  
  if(load.results==F)
  {
  load(file = paste0(loc,"/Results/model_inputs_no_age_correction.Rdata"))
  
  for.tune.all.res <- NULL
  for.tune.summary <- NULL
  for(i in Stocks)
  {
    years <- years.tmp[[i]]
    prop.nat.mort <- pnm.tmp[[i]] 
    #rem <- rem.tmp[[i]] 
    mx <- mx.tmp[[i]] 
    N.end <- NE.tmp[[i]] 
    ages <- ages.tmp[[i]]
    vpa.abund <- vpa.tmp[[i]] 
    abund <- abund.tmp[[i]]
    fs <-fs.tmp[[i]]
    full.rem <- full.rem.tmp[[i]]
    #full.abund <- full.abund.tmp[[i]]
    #all.abund <- full.abund.tmp[[i]]
    #N.end <- vpa.abund[length(vpa.abund)]
    #Pick your step size
    ss.size <- 0.005
    sensistive.stocks <- c("AFSC_GOA_Theragra_chalcogramma",
                            "DFO_2J3KL_Gadus_morhua",
                            "DFO_3Pn-4RS_Gadus_morhua",
                            "DFO_4T-4VN_Gadus_morhua",
                            "DFO_4T_Scomber_scombrus",
                            "ICES-AFWG_NEA1-2_Melanogrammus_aeglefinus",
                            "ICES-AFWG_NEA1-2_Gadus_morhua",
                            "ICES-HAWG_NS_Ammodytes_dubius",
                            "ICES-NWWG_FA5b_Pollachius_virens",
                            "ICES-NWWG_FAPL5b1_Gadus_morhua",
                            "ICES-WGBFAS_BS 22-32_Sprattus_sprattus",
                            "ICES-WGCSE_IS7a_Gadus_morhua",
                            "ICES-WGCSE_CS7a_Merlangius_merlangus",
                            "ICES-WGCSE_CS7e-k_Gadus_morhua",
                            "ICES-WGCSE_CS27.6a_Merlangius_merlangus",
                            "ICES-WGHANSA_SP8abd_Sardina _pilchardus", 
                            "ICES-WGNSSK_NS 4-7d,20_Gadus_morhua",
                            "ICES-WGNSSK_NS  4-6a-20_Melanogrammus_aeglefinus",
                            "ICES-WGNSSK_NS 4-7d_Merlangius_merlangus",
                            "ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii",
                            "NEFSC-GARMIII_SNE- MA_Limanda_ferruginea",
                            "NEFSC-GARMIII_MA_Paralichthys_dentatus",
                            "NEFSC-GARMIII_5Y_Melanogrammus_Aeglefinus",
                            "NEFSC_NWA_Scomber _scombrus")
    

    
    if(i %in% sensistive.stocks) ss.size = ss.size/10
  
     N.start <- vpa.abund[1]
     print(i)
     # The fecundities are 
     fast.for.tune <- fast.tunes(years,
                             tuner=what.2.tune,
                             step.size = ss.size, 
                             abund.ts = vpa.abund,
                             ages=ages,
                             nm = -(log(1-prop.nat.mort)),
                             fecund = mx,
                             fm = fs,
                             abund.age = abund, 
                             catch.age = full.rem, 
                             N.init = N.start,
                             direction= 'forwards'
                             )
     
     for.tune.all.res[[i]] <- fast.for.tune
     for.tune.tmp <- data.frame(fast.for.tune$res,Stock = i)
     for.tune.summary[[i]] <- for.tune.tmp
  }
 
  saveRDS(for.tune.summary,paste0(loc,"/Results/forwards_fully_tuned_summary_no_age_correction_",what.2.tune,".Rds"))
  saveRDS(for.tune.all.res,paste0(loc,"/Results/forwards_fully_tuned_all_no_age_corection_res_",what.2.tune,".Rds"))
  # 
}# end if load results


```

```{r paper-other-metrics-and-metadata,echo=F,include=F,warning=F,message=F}

if(load.results==F)
{
  # We are now looking at everything, lifetime reproductive success
  
  for.tune.summary <- readRDS(paste0(loc,"/Results/forwards_fully_tuned_summary_no_age_correction_",what.2.tune,".Rds"))
  for.tune.all <- readRDS(paste0(loc,"/Results/forwards_fully_tuned_all_no_age_corection_res_",what.2.tune,".Rds"))
  
  
  load(file =  paste0(loc,"/Results/model_inputs_no_age_correction.Rdata"))
  # Get the stocks...
  Stocks <- names(for.tune.summary)
  n.stocks <- length(Stocks)
  
  
  ############ Meta data and clean up, could be it's own chunk really, but it's really fast, so meh...
  
  #  A quick way to get the other potentially interesting info for the stock...
  drop <- which(names(ASR.long) %in% c("Year","type","age","value"))
  meta <- NULL
  for(i in Stocks) 
  {
    meta[[i]] <- ASR.long[ASR.long$Stock == i,-drop][1,]
    meta[[i]]$age.min <- min(ages.tmp[[i]])
    meta[[i]]$age.max <- max(ages.tmp[[i]])
  }
  meta <- do.call('rbind',meta)
  
  # First making a meta data object and adding a bunch of columns to it... very messy!!
  meta$Species[meta$Species == ' harengus']  <- "harengus"
  meta$Species[meta$Species == "Aeglefinus"] <- "aeglefinus"
  meta$Species[meta$Species == "Solea"] <- "solea"
  meta$Family[meta$Family == "Gadide"] <- "Gadidae"
  meta$Genus[meta$Genus == " Hippoglossoides"] <- "Hippoglossoides"
  meta$G.short <- toupper(paste0(substr(meta$Genus,1,1),"."))
  meta$G.Species <- paste0(meta$G.short," ",meta$Species)
  # Simplified Management
  meta$Manage.short <- meta$Management
  meta$Manage.short[grep("TRAC",meta$Management)] <- "DFO-TRAC"
  meta$Manage.short[grep("DFO",meta$Management)] <- "DFO-TRAC"
  meta$Manage.short[grep("NEFSC",meta$Management)] <- "NEFSC"
  meta$Manage.short[grep("ICES",meta$Management)] <- "ICES"
       
  # The 3 pieces of the ocean
  meta$LME <- "NW Atlantic"
  meta$LME[meta$Management == "AFSC"] <- "Pacific (Alaska)"
  meta$LME[grepl("ICES",meta$Management)] <- "NE Atlantic"
  # An area typo
  meta$Area[grep("BSAI-females",meta$Area)] <- "BSAI-Females"
  meta$Area[grep("BASI-Females",meta$Area)] <- "BSAI-Females"
  # Some other Area summaries
  meta$Area.broad <- meta$Area
  meta$Area.long <- meta$Area
  meta$Area.narrow <- "" # Leave this blank if not needed
       
  meta$Area.broad[grep("NS",meta$Area)] <- "NS"
  meta$Area.long[grep("NS",meta$Area)] <- "North Sea"
  meta$Area.broad[grep("CS",meta$Area)] <- "CS"
  meta$Area.long[grep("CS",meta$Area)] <- "Celtic Sea"
  meta$Area.broad[grep("ROCK6b",meta$Area)] <- "CS"
  meta$Area.long[grep("ROCK6b",meta$Area)] <- "Celtic Sea"
  meta$Area.broad[grep("IS",meta$Area)] <- "IS"
  meta$Area.long[grep("IS",meta$Area)] <- "Irish Sea"
  meta$Area.broad[grep("BS",meta$Area)] <- "BS"
  meta$Area.long[grep("BS",meta$Area)] <- "Baltic Sea"
  meta$Area.broad[grep("NEA",meta$Area)] <- "NEA"
  meta$Area.long[grep("NEA",meta$Area)] <- "NE Arctic"
  meta$Area.broad[grep("B28.1",meta$Area)] <- "BS"
  meta$Area.long[grep("B28.1",meta$Area)] <- "Baltic Sea"
  meta$Area.broad[grep("SP8abd",meta$Area)] <- "BoB"
  meta$Area.long[grep("SP8abd",meta$Area)] <- "Bay of Biscay"
  meta$Area.broad[grep("FA",meta$Area)] <- "Ice-Faroe"
  meta$Area.broad[grep("ICE",meta$Area)] <- "Ice-Faroe"
  meta$Area.long[grep("FA",meta$Area)] <- "Faroes"
  meta$Area.long[grep("ICE",meta$Area)] <- "Iceland"
  
  meta$Area.broad[grep("GOM",meta$Area)] <- "NAFO 5-6"
  meta$Area.long[grep("GOM",meta$Area)] <- "NAFO 5-6"
  meta$Area.broad[grep("GB",meta$Area)] <- "NAFO 5-6"
  meta$Area.long[grep("GB",meta$Area)] <- "NAFO 5-6"
  meta$Area.broad[grep("5Y",meta$Area)] <- "NAFO 5-6"
  meta$Area.long[grep("5Y",meta$Area)] <- "NAFO 5-6"
  meta$Area.broad[grep("5Z",meta$Area)] <- "NAFO 5-6"
  meta$Area.long[grep("5Z",meta$Area)] <- "NAFO 5-6"
  meta$Area.broad[grep("USATL",meta$Area)] <- "NAFO 5-6" # The fishery is broader than just GOM, but it does also include it.
  meta$Area.long[grep("USATL",meta$Area)] <- "NAFO 5-6" # The fishery is broader than just GOM, but it does also include it.
  meta$Area.broad[grep("NWA",meta$Area)] <- "NAFO 5-6" # Mackerel... so that definition is a bit narrow....
  meta$Area.long[grep("NWA",meta$Area)] <- "NAFO 5-6" # Mackerel... so that definition is a bit narrow....
  #meta$Area1[grep("SNE- MA",meta$Area)] <- "GOM-GB" # YT in US, so no GB so that definition is a bit narrow....
  meta$Area.broad[grep("MA",meta$Area)] <- "NAFO 5-6" # YT  and summer flounder in US, so no GB so that definition is a bit narrow....
  meta$Area.long[grep("MA",meta$Area)] <- "NAFO 5-6" # YT  and summer flounder in US, so no GB so that definition is a bit narrow....
  meta$Area.broad[grep("BSAI",meta$Area)] <- "BSAI"
  meta$Area.broad[grep("4T",meta$Area)] <- "NAFO 2-4"
  meta$Area.long[grep("4T",meta$Area)] <- "NAFO 2-4"
  meta$Area.broad[grep("2J3",meta$Area)] <- "NAFO 2-4"
  meta$Area.long[grep("2J3",meta$Area)] <- "NAFO 2-4"
  meta$Area.broad[grep("3Pn-4RS",meta$Area)] <- "NAFO 2-4"
  meta$Area.long[grep("3Pn-4RS",meta$Area)] <- "NAFO 2-4"
  meta$Area.long[grep("GOA",meta$Area)] <- "Gulf of Alaska"
  # Lumping everything in Berring Sea and AI into both.
  meta$Area.long[grep("AI",meta$Area)] <- "Aleutian Islands"
  meta$Area.long[grep("ESB",meta$Area)] <- "Bering Sea & AI" 
  meta$Area.long[grep("BSAI",meta$Area)] <- "Bering Sea & AI"
  meta$Area[grep("BASI-Females",meta$Area)] <- "BSAI"
  meta$Area[grep("BSAI-Females",meta$Area)] <- "BSAI"
  meta$Area[grep("BSAI-females",meta$Area)] <- "BSAI"
  meta$Area.long[grep("BSAI-Females",meta$Area)] <- "Bering Sea & AI"
  meta$Area.narrow[meta$Stock == "ICES-NWWG_FA5b_Pollachius_virens"] <- "5b"
  meta$Area.narrow[meta$Stock == "ICES-NWWG_FA5a_Pollachius_virens"] <- "5a"
  meta$Area.narrow[meta$Stock == "ICES-WGNSSK_NS4 _Solea_solea"] <- "4"
  meta$Area.narrow[meta$Stock == "ICES-WGNSSK_NS 7d._Solea_solea"] <- "7d"
  meta$Area.narrow[meta$Stock == "ICES-WGBFAS_NS IIIa 22-24_Solea_Solea"] <- "22-24"
  meta$Area.narrow[meta$Stock == "ICES-WGNSSK_NS 7d_Pleuronectes_platessa"] <- "7d"
  meta$Area.narrow[meta$Stock == "ICES-WGNSSK_NS 4,20_Pleuronectes_platessa"] <- "4 20"
  meta$Area.narrow[meta$Stock == "ICES-WGCSE_IS7e_Pleuronectes_platessa"] <- "7e"
  meta$Area.narrow[meta$Stock == "ICES-WGCSE_IS27.7a_Pleuronectes_platessa"] <- "7a"
  meta$Area.narrow[meta$Stock == "ICES-NWWG_FA5b_Melanogrammus_aeglefinus"] <- "5b"
  meta$Area.narrow[meta$Stock == "ICES-NWWG_ICE5a_Melanogrammus_aeglefinus"] <- "5a"
  meta$Area.narrow[meta$Stock == "ICES-WGBFAS_B28.1_Clupea_harengus"] <- "28"
  meta$Area.narrow[meta$Stock == "ICES-WGBFAS_BS 25-29-32_Clupea_harengus" ] <- "25-32"
  meta$Area.narrow[meta$Stock == "ICES-HAWG_WBS 22-24_Clupea_harengus"] <- "22-24"
  meta$Area.narrow[meta$Stock == "DFO_4T-Fall_Clupea_harengus"] <- "Fa-SGSL"
  meta$Area.narrow[meta$Stock == "DFO_4T-Spring_Clupea_harengus"] <- "Sp-SGSL"
  meta$Area.narrow[meta$Stock == "ICES-WGCSE_CS27.6a_Merlangius_merlangus"] <- "27.6a"
  meta$Area.narrow[meta$Stock == "ICES-WGCSE_CS7a_Merlangius_merlangus"] <- "7a"
  meta$Area.narrow[meta$Stock == "ICES-NWWG_ICE5a_Gadus_morhua"] <- "5a"
  meta$Area.narrow[meta$Stock == "ICES-NWWG_FAPL5b1_Gadus_morhua" ] <- "5b"
  meta$Area.narrow[meta$Stock == "ICES-WGNSSK_NS 4-7d,20_Gadus_morhua"] <- "4-7 20"
  meta$Area.narrow[meta$Stock == "ICES-WGCSE_NS6a_Gadus_morhua"] <- "6a"
  meta$Area.narrow[meta$Stock == "DFO_2J3KL_Gadus_morhua"] <- "NFLD"
  meta$Area.narrow[meta$Stock == "DFO_3Pn-4RS_Gadus_morhua"] <- "NGSL"
  meta$Area.narrow[meta$Stock == "NEFSC-CERT-TRAC_GB _Gadus_morhua"] <- "EGB"
  meta$Area.narrow[meta$Stock == "ICES-WGCSE_ROCK6b_Melanogrammus_aeglefinus"] <- "RA"
  meta$Area.narrow[meta$Stock == "DFO_4T-4VN_Gadus_morhua"] <- "SGSL"
  meta$Area.narrow[meta$Stock == "DFO_4T_Hippoglossoides _platessoides"] <- "SGSL"
  meta$Area.narrow[meta$Stock == "DFO_4T_Scomber_scombrus"] <- "SGSL"
  meta$Area.narrow[meta$Stock == "NEFSC-SAW_GOM_Gadus_morhua"] <- "GOM"
  meta$Area.narrow[meta$Stock == "NEFSC-GARMIII_GB_Gadus_morhua"] <- "GB"
  meta$Area.narrow[meta$Stock == "NEFSC-GARMIII_5Y_Melanogrammus_Aeglefinus"] <- "GOM"
  meta$Area.narrow[meta$Stock == "CERT-TRAC_GB_Melanogrammus_Aeglefinus"] <- "GB"
  
  meta$Stock.short <- paste0(meta$Area.broad," ",meta$Area.narrow," ",meta$G.short," ",meta$Species)
  meta$Stock.no.species <- paste0(meta$Area.long," ",meta$Area.narrow)

  
  for.tune.stocks <- NULL
  fta <- NULL
  
  # Going to rename these female stocks.
  fem.names <- c("AFSC_BASI-Females_Pleuronectes_quadrituberculatus",
                    "AFSC_EEBSAI-Females_Lepidopsetta_polyxystra",
                    "AFSC_BSAI-females_Atheresthes_stomais")
  fem.rename <- c("AFSC_BSAI_Pleuronectes_quadrituberculatus",
                    "AFSC_EEBSAI_Lepidopsetta_polyxystra",
                    "AFSC_BSAI_Atheresthes_stomais")
  # Going to drop these stocks
  dont <- paste(c("Mles","Males","COASTNOR"),collapse = "|")
  
  meta.sub <- NULL
  for(i in Stocks) 
  {
    org.nam <- i
    tmp <- for.tune.summary[[org.nam]]
    new.stock.nam <- org.nam
    # Don't bother for these stocks...
    if(!grepl(dont,tmp$Stock[1]))
    {
      # Grab the metadata and add in some new useful things...
      meta.sub[[i]] <- meta[meta$Stock == org.nam,]
        
      # Rename the ladies
      if(tmp$Stock[1] == fem.names[1]) new.stock.nam <- tmp$Stock <- fem.rename[1]
      if(tmp$Stock[1] == fem.names[2]) new.stock.nam <- tmp$Stock <- fem.rename[2]
      if(tmp$Stock[1] == fem.names[3]) new.stock.nam <- tmp$Stock <- fem.rename[3]
      
      meta.sub[[i]]$Stock <- new.stock.nam
      tmp <- data.frame(tmp,meta.sub[[i]])
      # For tunes all
      fta[[new.stock.nam]] <- for.tune.all[[org.nam]]
      fta[[new.stock.nam]]$meta <- meta.sub[[i]]
      for.tune.stocks[[new.stock.nam]] <- tmp
    }# End skip stocks...
  }
  # Now unpack them...
  for.tunes <- do.call("rbind",for.tune.stocks)
  for.tune.all <- fta
  meta.sub <- do.call("rbind",meta.sub)
  
  ######################### End Meta data and clean up #####################
  
  
  # Now some summaries...
  
  # Reset on the stocks...
  Stocks <- sort(names(for.tune.all))
  n.stocks <- length(Stocks)

  
  # Doubling time, no fishing
  dt.res <- NULL
  # These are both set in the index file now, go there!!
  n.dt.sims <- n.dt.sims
  n.sim.years <- n.sim.years
  for(i in Stocks)
  {
    str.time <- Sys.time()
    try <- for.tune.all[[i]]
    meta.tmp <- try$meta
    age.4.sim <- meta.tmp$age.min:meta.tmp$age.max
    double.time <- NA
    pop <- 1000
    tmp.res <- NULL
  for(s in 1:n.dt.sims)
  {
    tmp <- rep(0,n.sim.years)
    print(paste0("Sim # ", s))

    for(y in 2:n.sim.years)
    {
      
      # Get our sample for this run
      f.pick <- sample(nrow(try$fecund.opt),size=1)
      nm.pick <- sample(nrow(try$nm.opt),size=1)
      fec.samp <- try$fecund.opt[f.pick,]
      # This is instantaneous rate, which is what the Lotka function is expected (it is set up expecting instantaneous)
      nm.samp <- try$nm.opt[nm.pick,] 
      # now put these into Euler-lotka to get an r estimate
      res <- simple.lotka.r(mort = nm.samp,fecund=fec.samp,ages=age.4.sim)
      r.val <- res$res$r
      # If r is > 5 (lambda = exp(5)) it generally means the simple.lotka didn't converge (bad combo of fec and nm)
      # So we'll need to resample them until it is < 5
      while(r.val >= 5)
      {
        print("Resampling due to bat shit r value")
        f.pick <- sample(nrow(try$fecund.opt),size=1)
        nm.pick <- sample(nrow(try$nm.opt),size=1)
        fec.samp <- try$fecund.opt[f.pick,]
        # This is instantaneous rate, which is what the Lotka function is expected (it is set up expecting instantaneous)
        nm.samp <- try$nm.opt[nm.pick,] 
        # now put these into Euler-lotka to get an r estimate
        res <- simple.lotka.r(mort = nm.samp,fecund=fec.samp,ages=age.4.sim)
        r.val <- res$res$r
      } # end while loop
      pop[y] <- exp(r.val)*pop[y-1]
      if(pop[y] >= 2*pop[1] & tmp[y] == 0) tmp[y:n.sim.years] <- 1
    } # end the years loop
    tmp.res[[s]] <- data.frame(year =1:n.sim.years,doubled = tmp,sim=s)
    
    } # end sim loop
    res.tmp <- do.call("rbind",tmp.res)
    
  dt.res[[i]] <- data.frame(res.tmp,meta.tmp)
  count <- 0
  timer <- round(difftime(Sys.time(),str.time,units='mins'),digits=1)
  print(paste0("Stock ",i," time =", timer," minutes: Stock # ",count+1))
  } # end Stocks loop
  
  dub.time <- do.call("rbind",dt.res)
  
  dub.time.summary <- dub.time |> collapse::fgroup_by(Stock,year)  |> collapse::fsummarise(prop = sum(doubled)/n.dt.sims)
  dub.time.summary <- left_join(dub.time.summary,meta.sub,by="Stock")
  
  # Now to get generation lengths + reproductive rates....
  # First I need to get the fecundity and natural mortalities by cohort instead of year.
  res.fin <- NULL
  res.year.fin <- NULL
  res.lambda.fin <- NULL
  for(i in Stocks) # 
  {
    tst <- for.tune.all[[i]]
    meta.tmp <- tst$meta
    # Fishing mortality
    fm.org.tmp <- tst$fm.org
    fm.tmp <- tst$fm.opt
    # fecundity
    fec.tmp <- tst$fecund.opt
    fec.org.tmp <- tst$fecund.org
    # Natural mortality
    m.org.tmp <- exp(-tst$nm.org) # This is survivorship
    m.tmp <- exp(-tst$nm.opt) # This is survivorship
    # Total mortality
    z.tmp <- exp(-tst$z.opt) # This is survivorship
    z.org.tmp <- exp(-tst$nm.org -fm.org.tmp) # This is survivorship
    
    ages <- meta.tmp$age.min:meta.tmp$age.max
    n.ages <- length(ages)
    years <- tst$res$year
    n.years <- length(years)
    # Now I need to grab the fecundities and nat morts by cohort
    if(n.years > n.ages)
    {
    res.cohort <- NULL
    res.year <- NULL
    res.lambda <- NULL
    for(y in 1:(n.years-n.ages+1))
    {
      count = 0
      fs <- NA
      # The lx is no fishing survivorship, zx I'm calling the survivorship including fishing
      lx <- lx.org <- lx.year <- zx <- zx.org <- zx.year <- 1
      fs.org <- NA
      
      for(a in 1:n.ages)
      {
      fs[a] <- fec.tmp[y+count,a]  
      fs.org[a] <- fec.org.tmp[y+count,a]  
      if(a > 1) 
      {
        # No fishing
        lx[a] <- lx[a-1] * m.tmp[y+count,a]  
        lx.org[a] <- lx.org[a-1]* m.org.tmp[y+count,a]  
        lx.year[a] <- lx.year[a-1] * m.tmp[y,a]
        # Including fishing
        zx[a] <- zx[a-1] * z.tmp[y+count,a]  
        zx.org[a] <- zx.org[a-1]* z.org.tmp[y+count,a]  
        zx.year[a] <- zx.year[a-1] * z.tmp[y,a]
      }  # end the a > 1 if
          count <- count + 1
      }# end the ages loop
          res.cohort[[y]] <- data.frame(mx.opt = fs,lx.opt = lx,mx.org = fs.org,
                                 mx.lx.opt = fs*lx,mx.lx.org = fs.org*lx.org,
                                 x.mx.lx.opt = fs*lx*ages,x.mx.lx.org = fs.org*lx.org*ages,
                                 zx.opt = zx,
                                 mx.zx.opt = fs*zx,mx.zx.org = fs.org*zx.org,
                                 x.mx.zx.opt = fs*zx*ages,x.mx.zx.org = fs.org*zx.org*ages,
                                 cohort=years[y],age = ages,meta.tmp)
          
          res.year[[y]] <- data.frame(mx.opt = unlist(fec.tmp[y,]),lx.opt = lx.year,
                                 mx.lx.opt = unlist(fec.tmp[y,])*lx.year,
                                 x.mx.lx.opt = unlist(fec.tmp[y,])*lx.year*ages,
                                 zx.opt = zx.year,
                                 mx.zx.opt = unlist(fec.tmp[y,])*lx.year,
                                 x.mx.zx.opt = unlist(fec.tmp[y,])*lx.year*ages,
                                 age = ages,year=years[y],meta.tmp)
  
    } # end the years loop
  
  # Do a years loop to get lambda with no fishing for each year, rather than by cohort...
    for(yy in 1:(n.years-1))
    {
      nm <- as.numeric(tst$nm.opt[yy,])
      z <- as.numeric(tst$z.opt[yy,])
      fec <- as.numeric(tst$fecund.opt[yy,])
      nm.init <- as.numeric(tst$nm.org[yy,])
      fec.init <- as.numeric(tst$fecund.org[yy,])
      z.init <- as.numeric(tst$z.org[yy,])
      lam.no.fish <- exp(simple.lotka.r(mort = nm,fecund = fec,ages=ages)$res$r)
      lam.fish <- exp(simple.lotka.r(mort = z,fecund = fec,ages=ages)$res$r)
      lam.org.no.fish <- exp(simple.lotka.r(mort = nm.init,fecund = fec.init,ages=ages)$res$r)
      lam.org.fish <- exp(simple.lotka.r(mort =  z.init,fecund = fec.init,ages=ages)$res$r)
      
      # Now summarize these
      res.lambda[[yy]] <-  data.frame(lam.no.fish = lam.no.fish,lam.fish = lam.fish,
                                      lam.org.no.fish = lam.org.no.fish,
                                      lam.org.fish = lam.org.fish,
                                      year=years[yy],meta.tmp)
    } # End the yy loop to get the lambdas...
  # unpack it...
  res.fin[[i]] <- do.call('rbind',res.cohort)
  res.year.fin[[i]] <- do.call('rbind',res.year)
  res.lambda.fin[[i]] <-  do.call('rbind',res.lambda)
  }  # end if to make sure we have enough data to get the cohort estimates.
  
  }# end the stock loop
  
  res.cohort.final <- do.call('rbind',res.fin)
  res.year.final <- do.call('rbind',res.year.fin)
  res.lambda.final <- do.call('rbind',res.lambda.fin)
  
  pop.dam <- res.cohort.final |> collapse::fgroup_by(cohort,Stock) |> collapse::fsummarise(gen.len.opt = sum(x.mx.lx.opt)/sum(mx.lx.opt),
                                                                                   gen.len.org = sum(x.mx.lx.org)/sum(mx.lx.org),
                                                                                   R0.opt = sum(mx.lx.opt),R0.org = sum(mx.lx.org))
  pop.dam <- left_join(pop.dam,meta.sub,by="Stock")
  
  dub.time.summary <- data.frame(dub.time.summary)
  pop.dam <- data.frame(pop.dam)
  # saveRDS(pop.dam,paste0("D:/Github/ICM/Results/R0_and_gen_length_",what.2.tune,".Rds"))
  # saveRDS(dub.time.summary,paste0("D:/Github/ICM/Results/doubling_time_",what.2.tune,".Rds"))
  # saveRDS(for.tunes,paste0("D:/Github/ICM/Results/forward_tunes_for_figures_",what.2.tune,".Rds"))
  save(dub.time.summary,pop.dam,res.year.final,res.cohort.final,for.tunes,dub.time,for.tune.all,res.lambda.final,meta,meta.sub,
       file=paste0(loc,"/Results/all_cleaned_forward_tune_summaries_no_age_corection_",what.2.tune,".Rdata"))
  
  write.csv(meta.sub, paste0(loc,"/Data/metadata_no_age_corection.csv"))
} # end if load results
```



```{r clean-up-and-stats,include=F,echo=F,message=F,warning=F}
load(file=paste0(loc,"/Results/all_cleaned_forward_tune_summaries_no_age_corection_",what.2.tune,".Rdata"))
for.tune.summary <- readRDS(paste0(loc,"/Results/forwards_fully_tuned_summary_no_age_correction_",what.2.tune,".Rds"))

Stocks <- unique(res.lambda.final$Stock)
res.lambda.fin <- data.frame(res.lambda.final)
six.species <- c('morhua','harengus','aeglefinus','virens','solea','platessa')
pop.dam <- pop.dam |> collapse::fgroup_by(Stock) |> 
                           collapse::fmutate(med.gen.len = median(gen.len.opt,na.rm=T),med.r0 = median(R0.opt,na.rm=T)) |>
                           as.data.frame()
pop.dam.6 <- pop.dam |> collapse::fsubset(Species %in% six.species)
for.tunes.6 <- for.tunes |> collapse::fsubset(Species %in% six.species)
dub.time.6 <- dub.time.summary |> collapse::fsubset(Species %in% six.species)
res.lambda.fin$decade <- floor(res.lambda.fin$year/10)*10
res.lambda.fin <- res.lambda.fin |> collapse::fgroup_by(Stock,decade) |> collapse::fmutate(mn.lam = mean(lam.fish,na.rm=T),
                                                                                 med.lam = median(lam.fish,na.rm=T),
                                                                                 sd.lam = sd(lam.fish,na.rm=T))
res.lambda.fin <- res.lambda.fin |> collapse::fgroup_by(Species,decade) |> collapse::fmutate(lm.spec.mn = mean(mn.lam,na.rm=T))              
res.lambda.fin <- res.lambda.fin |> collapse::fgroup_by(Stock) |> 
                                                          collapse::fmutate(
                                                          lam.no.fish.mn = mean(lam.no.fish,na.rm=T),
                                                          lam.fish.mn = mean(lam.fish,na.rm=T),
                                                          lam.org.no.fish.mn = mean(lam.org.no.fish,na.rm=T),
                                                          lam.org.fish.mn = mean(lam.org.fish,na.rm=T),
                                                          lam.no.fish.med = median(lam.no.fish,na.rm=T),
                                                          lam.fish.med = median(lam.fish,na.rm=T),
                                                          lam.org.no.fish.med = median(lam.org.no.fish,na.rm=T),
                                                          lam.org.fish.med = median(lam.org.fish,na.rm=T),
                                                          lam.no.fish.sd = sd(lam.no.fish,na.rm=T),
                                                          lam.fish.sd = sd(lam.fish,na.rm=T),
                                                          lam.org.no.fish.sd = sd(lam.org.no.fish,na.rm=T),
                                                          lam.org.fish.sd = sd(lam.org.fish,na.rm=T)
                                                          ) |> data.frame()
# Get the order right for the stock no species for the boxplots to come later
sns.order <- c("Baltic Sea ", "Baltic Sea 22-24", "Baltic Sea 25-32", "Baltic Sea 28", 
               "North Sea ", "North Sea 4", "North Sea 22-24", "North Sea 4-7 20", "North Sea 6a","North Sea 4 20", "North Sea 7d",     
               "Celtic Sea ","Celtic Sea RA", "Celtic Sea 7a", "Celtic Sea 27.6a", 
               "Irish Sea ","Irish Sea 7a", "Irish Sea 7e","Bay of Biscay ", "NE Arctic ", 
               "Faroes 5a", "Faroes 5b",  "Iceland ", "Iceland 5a",
                "NAFO 2-4 Fa-SGSL", "NAFO 2-4 Sp-SGSL", "NAFO 2-4 SGSL", "NAFO 2-4 NGSL", "NAFO 2-4 NFLD",  
                "NAFO 5-6 ", "NAFO 5-6 GB", "NAFO 5-6 GOM", "NAFO 5-6 EGB",
                "Bering Sea & AI ", "Gulf of Alaska ", "Aleutian Islands ")

res.lambda.fin$Stock.no.species <- factor(res.lambda.fin$Stock.no.species,levels = sns.order,ordered = T)
res.lambda.final.6 <- res.lambda.fin |> collapse::fsubset(Species %in% six.species)
# Sort the data into a nice order...
res.lambda.fin <- res.lambda.fin |> collapse::roworder(Species,Area.broad) |>
                                    collapse::fmutate(Stock.no.species = forcats::fct_inorder(factor(Stock.no.species, ordered=TRUE)))
# Making the Aleutian Islands their own Area long...
res.lambda.fin$Area.long[res.lambda.fin$Area == "AI"] <- "Aleutian Islands"
res.lambda.fin$Area.long <- factor(res.lambda.fin$Area.long,levels = c("Baltic Sea", "North Sea","Celtic Sea",
                                                                       "Irish Sea","Bay of Biscay","NE Arctic",
                                                                       "Faroes","Iceland","NAFO 2-4","NAFO 5-6","Gulf of Alaska","Bering Sea & AI","Aleutian Islands"),ordered = T)

res.lambda.final.6 <- res.lambda.final.6 |> collapse::roworder(Species,Area.broad) |>
                                            collapse::fmutate(Stock.no.species = forcats::fct_inorder(factor(Stock.no.species, ordered=TRUE)))
dub.time <- dub.time |> collapse::roworder(LME) |>
                        collapse::fmutate(Stock.no.species = forcats::fct_inorder(factor(Stock.no.species, ordered=TRUE)))

dub.time.summary <- dub.time.summary |> collapse::roworder(LME,Order,Species,Area.broad) |>
                                        collapse::fmutate(Stock.short = forcats::fct_inorder(factor(Stock.short, ordered=TRUE)))

dub.time.6 <- dub.time.6 |> collapse::roworder(LME) |>
                             collapse::fmutate(Stock.no.species = forcats::fct_inorder(factor(Stock.no.species, ordered=TRUE)))
pop.dam <- pop.dam |> collapse::roworder(Species,LME) |>
                       collapse::fmutate(Stock = forcats::fct_inorder(factor(Stock, ordered=TRUE)))
pop.dam.6 <- pop.dam.6 |> collapse::roworder(LME,Area.broad) |>
                       collapse::fmutate(Stock.no.species = forcats::fct_inorder(factor(Stock.no.species, ordered=TRUE)))
pop.dam$Area.long[pop.dam$Area == "AI"] <- "Aleutian Islands"
pop.dam$Area.long <- factor(pop.dam$Area.long,levels = c("Baltic Sea", "North Sea","Celtic Sea",
                                                         "Irish Sea","Bay of Biscay","NE Arctic",
                                                         "Faroes","Iceland","NAFO 2-4","NAFO 5-6","Gulf of Alaska","Bering Sea & AI","Aleutian Islands"),ordered = T)
# I'd also like a pop.dam including fishing
pop.dam.fish <- res.cohort.final |> collapse::fgroup_by(cohort,Stock) |> collapse::fsummarise(gen.len.opt = sum(x.mx.zx.opt)/sum(mx.zx.opt),
                                                                                   gen.len.org = sum(x.mx.zx.org)/sum(mx.zx.org),
                                                                                   R0.opt = sum(mx.zx.opt),R0.org = sum(mx.zx.org))
pop.dam.fish <- left_join(pop.dam.fish,meta.sub,by="Stock")
pop.dam.fish$Area.long[pop.dam.fish$Area == "AI"] <- "Aleutian Islands"
pop.dam.fish$Area.long <- factor(pop.dam.fish$Area.long,levels = c("Baltic Sea", "North Sea","Celtic Sea",
                                                         "Irish Sea","Bay of Biscay","NE Arctic",
                                                         "Faroes","Iceland","NAFO 2-4","NAFO 5-6","Gulf of Alaska","Bering Sea & AI","Aleutian Islands"),ordered = T)

pop.dam.fish <- pop.dam.fish |> collapse::fgroup_by(Stock) |> 
                           collapse::fmutate(med.gen.len = median(gen.len.opt,na.rm=T),med.r0 = median(R0.opt,na.rm=T)) |>
                           as.data.frame()

#pop.dam <- data.frame(pop.dam)

pop.dam.fish <- pop.dam.fish |> collapse::roworder(Species,LME) |>
                                collapse::fmutate(Stock = forcats::fct_inorder(factor(Stock, ordered=TRUE)))
pop.dam.fish.6 <- pop.dam.fish |> collapse::fsubset(Species %in% six.species)

pop.dam.fish.6 <- pop.dam.fish.6 |> collapse::roworder(LME,Area.broad) |>
                                    collapse::fmutate(Stock.no.species = forcats::fct_inorder(factor(Stock.no.species, ordered=TRUE)))

# Put the population dynamics stuff together.
pop.dam$group <- "no fish"
pop.dam.fish$group <- 'fish'
pop.dam.all <- rbind(pop.dam,pop.dam.fish)

pop.dam.6$Stock.no.species <- factor(pop.dam.6$Stock.no.species,levels = sns.order,ordered = T)
pop.dam$Stock.no.species <- factor(pop.dam$Stock.no.species,levels = sns.order,ordered = T)
pop.dam.fish.6$Stock.no.species <- factor(pop.dam.fish.6$Stock.no.species,levels = sns.order,ordered = T)
pop.dam.fish$Stock.no.species <- factor(pop.dam.fish$Stock.no.species,levels = sns.order,ordered = T)
pop.dam.all$Stock.no.species <- factor(pop.dam.all$Stock.no.species,levels = sns.order,ordered = T)
# Drop the periods....
pop.dam.all.6 <- pop.dam.all |> collapse::fsubset(!Species %in% six.species)
pop.dam.all$G.Species <- gsub("\\.","",pop.dam.all$G.Species)
pop.dam.all$G.Species.short <- substr(pop.dam.all$G.Species,1,5)
pop.dam.all$G.Species <- gsub("\\.","",pop.dam.all$G.Species)
pop.dam.all.6 <- pop.dam.all |> collapse::fsubset(Species %in% six.species)
pop.dam.all.others <- pop.dam.all |> collapse::fsubset(!Species %in% six.species)


# Reorder the doubling time, either by Species and LME, or the other way around

dub.time.summary$Order.short <- "Gadi"
dub.time.summary$Order.short[dub.time.summary$Order == "Pleuronectiformes"] <- "Plero"
dub.time.summary$Order.short[dub.time.summary$Order == "Clupeiformes"] <- "Clupei"
dub.time.summary$Order.short[dub.time.summary$Order == "Scorpaeniformes "] <- "Scor"
dub.time.summary$Order.short[dub.time.summary$Order == "Scombriformes"] <- "Scomb"
dub.time.summary$Order.short[dub.time.summary$Order == "Perciformes"] <- "Perci"
# First need to get the abundance and lambdas with no fishing into one object.
ft.tmp <- for.tunes |> collapse::fselect(year,Stock,vpa.abund,est.abund,removals)
dd.dat <- left_join(res.lambda.fin,ft.tmp,by=c('year','Stock'))
# Now I need to get a relative abundance for each stock...
dd.dat <- dd.dat |> collapse::fgroup_by(Stock) |> collapse::fmutate(max.abund = max(est.abund,na.rm=T))
dd.dat <- data.frame(dd.dat)
dd.dat$prop.abund <- dd.dat$est.abund/dd.dat$max.abund
# Drop nas....
drops <- -which(is.na(dd.dat$prop.abund))
dd.dat <- dd.dat[drops,]
#lump the data into bins
dd.dat$prop.bin <- "< 10%"
dd.dat$prop.bin[dd.dat$prop.abund > 0.1 & dd.dat$prop.abund <= 0.2] <- "10-20%"
dd.dat$prop.bin[dd.dat$prop.abund > 0.2 & dd.dat$prop.abund <= 0.3] <- "20-30%"
dd.dat$prop.bin[dd.dat$prop.abund > 0.3 & dd.dat$prop.abund <= 0.4] <- "30-40%"
dd.dat$prop.bin[dd.dat$prop.abund > 0.4 & dd.dat$prop.abund <= 0.6] <- "40-60%"
dd.dat$prop.bin[dd.dat$prop.abund > 0.6 & dd.dat$prop.abund <= 0.8] <- "60-80%"
dd.dat$prop.bin[dd.dat$prop.abund > 0.8 & dd.dat$prop.abund <= 1] <- "80-100%"
dd.dat$prop.bin <- factor(dd.dat$prop.bin,levels=c("< 10%","10-20%","20-30%","30-40%","40-60%","60-80%","80-100%"))

# Subset to the big six
dd.dat.six <- dd.dat  |>collapse::fsubset(Species %in% six.species)

# This is for the new lambda figures with fishing and no fishing together

res.lambda.fin.long <- res.lambda.fin |> tidyr::pivot_longer(cols = c(lam.no.fish,lam.fish),names_to = 'group',values_to = 'lambda')
res.lambda.fin.long$Stock.no.species <- factor(res.lambda.fin.long$Stock.no.species,levels = sns.order,ordered = T)
res.lambda.fin.long$group <- substr(res.lambda.fin.long$group,5,20)
res.lambda.fin.long$group <- gsub("\\."," ",res.lambda.fin.long$group)
res.lambda.fin.long <- res.lambda.fin.long |> collapse::fgroup_by(group,Stock) |> collapse::fmutate(med.lam.stock = median(lambda,na.rm=T))

res.lambda.fin.long.others <- res.lambda.fin.long |> as.data.frame() |> collapse::fsubset(!Species %in% six.species)
res.lambda.fin.long.others$G.Species <- gsub("\\.","",res.lambda.fin.long.others$G.Species)
res.lambda.fin.long.others$G.Species.short <- substr(res.lambda.fin.long.others$G.Species,1,5)

res.lambda.fin.long.6 <- res.lambda.fin.long |> as.data.frame() |> collapse::fsubset(Species %in% six.species)
res.lambda.fin.long.6$G.Species <- gsub("\\.","",res.lambda.fin.long.6$G.Species)

# GAM FOR DENSITY DEPENENCE# GAM FOR DENSITY DEPENENCE# GAM FOR DENSITY DEPENENCE# GAM FOR DENSITY DEPENENCE# GAM FOR DENSITY DEPENENCE
# here is the GAM for no fishing with subsequent processing.
mod.dd.stock.gam.nf <- gam(log(lam.no.fish) ~   s(prop.abund,k=4) + s(prop.abund,as.factor(Stock.short),bs='fs',k=3) ,data=dd.dat)

# This extracts the GAM fit so we can custom plot it on our own figure
tmp <- plot(mod.dd.stock.gam.nf, pages = 0) # Leave a space after this so the code runs (it needs a return as this thing makes a two panel figure)

no.stock.gam.nf.dat <- data.frame(fit = tmp[[1]]$fit + coefficients(mod.dd.stock.gam.nf)[1],prop.abund = tmp[[1]]$x,se = tmp[[1]]$se,Scenario = "F = 0")
no.stock.gam.nf.dat$LCI <- no.stock.gam.nf.dat$fit - 1.96*no.stock.gam.nf.dat$se
no.stock.gam.nf.dat$UCI <- no.stock.gam.nf.dat$fit + 1.96*no.stock.gam.nf.dat$se

#summary(mod.dd.stock.gam.nf)
#Residuals, definitely still issues here, maybe a bit better than some others, maybe...
#plot(residuals(mod.dd.stock.gam.nf) ~ fitted(mod.dd.stock.gam.nf))
# Normality = no
#qqnorm(residuals(mod.dd.stock.gam.nf))
#qqline(residuals(mod.dd.stock.gam.nf))

pred.dd.stock.gam.nf <- expand.grid(prop.abund = seq(0, 1, length.out = 250),
                                         Stock.short=c(unique(dd.dat$Stock.short)))
tmp <- predict(mod.dd.stock.gam.nf, pred.dd.stock.gam.nf, type = 'response', se.fit = TRUE) 
# Another fun trick to extract the overall smooth fit, but didn't end up using this method.
# sms <- smooths(mod.dd.stock.gam.nf)
# excl <- grepl("as.factor",sms)
# rm <- sms[excl]
# tmp.ex <- predict(mod.dd.stock.gam.nf, newdata =pred.dd.stock.gam.nf, type = 'response', se.fit = TRUE,exclude =rm) 
# Get the fit by stock
pred.dd.stock.gam.nf$lam.no.fish   <- exp(tmp$fit)
pred.dd.stock.gam.nf$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
pred.dd.stock.gam.nf$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)

# Thin the data so I can add points to the figure
tmp <- NULL
for(i in 1:(77)) 
{
  if(i==1) tmp[[i]] <- seq(10,230,length.out=5)
  if(i>1) tmp[[i]] <- seq(10,230,length.out=5)+250*(i-1)
}
thinner.nf <- do.call('c',tmp)
thin.pred.nf <- pred.dd.stock.gam.nf[thinner.nf,]
# Now I want to get rid of extrapolation from this prediction data.frame, I think I need to loop it...
# 
short.stocks <- unique(dd.dat$Stock.short)
n.stocks <- length(short.stocks)
pred.out <- NULL
thin.out <- NULL
for(i in short.stocks)
{
  # Get the right stocks
  tmpy <- dd.dat |> collapse::fsubset(Stock.short == i)
  tmp.pred <- pred.dd.stock.gam.nf |> collapse::fsubset(Stock.short == i)
  tmp.thin <- thin.pred.nf |> collapse::fsubset(Stock.short == i)
  # I dont want to predict below the minimum observed abundance
  mins <- min(tmpy$prop.abund,na.rm=T)
  pred.out[[i]] <- tmp.pred |> collapse::fsubset(prop.abund >= mins)
  thin.out[[i]] <- tmp.thin |> collapse::fsubset(prop.abund >= mins)
}

pred.dd.stock.gam.ss.nf <- do.call('rbind',pred.out)
thin.pred.nf <- do.call('rbind',thin.out)
# Combine pred stuff with the meta data for fun plots
pred.dd.stock.gam.ss.nf <- left_join(pred.dd.stock.gam.ss.nf,meta.sub,by="Stock.short")
pred.dd.stock.gam.ss.nf <- data.frame(pred.dd.stock.gam.ss.nf)
thin.pred.nf <- left_join(thin.pred.nf,meta.sub,by="Stock.short")
# Here are the fits (sans SE cause messy + didn't put the overall relationship on here)
# By region
cols.gam <- rep(c("black","blue","orange",'firebrick2','lightgreen'),6)
pty.gam <- c(rep(0,5),rep(1,5),rep(2,5),rep(3,5),rep(4,5),rep(5,5))

# Now do the same thing with the data that includes the effect of fishing.

#mod.dd.stock.gam.fish <- gam(log(lam.fish) ~  as.factor(Stock.short) + s(prop.abund,by=as.factor(Stock.short),k=3),data=dd.dat)
mod.dd.stock.gam.fish <- gam(log(lam.fish) ~  s(prop.abund,k=4) + s(prop.abund,as.factor(Stock.short),bs='fs',k=3),data=dd.dat)

tmp <- plot(mod.dd.stock.gam.fish, pages = 0) # Leave a space after this so the code runs (it needs a return as this thing makes a two panel figure)

no.stock.gam.fish.dat <- data.frame(fit = tmp[[1]]$fit + coefficients(mod.dd.stock.gam.fish)[1],prop.abund = tmp[[1]]$x,se = tmp[[1]]$se,Scenario = "F > 0")
no.stock.gam.fish.dat$LCI <- no.stock.gam.fish.dat$fit - 1.96*no.stock.gam.fish.dat$se
no.stock.gam.fish.dat$UCI <- no.stock.gam.fish.dat$fit + 1.96*no.stock.gam.fish.dat$se

#summary(mod.dd.stock.gam.fish)
#Residuals, definetly still issues here, maybe a bit better than some others, maybe...
#plot(residuals(mod.dd.stock.gam.fish) ~ fitted(mod.dd.stock.gam.fish))
# Normality = no
#qqnorm(residuals(mod.dd.stock.gam.fish))
#qqline(residuals(mod.dd.stock.gam.fish))

pred.dd.stock.gam.fish <- expand.grid(prop.abund = seq(0, 1, length.out = 250),
                                         Stock.short=c(unique(dd.dat$Stock.short)))
tmp <- predict(mod.dd.stock.gam.fish, pred.dd.stock.gam.fish, type = 'response', se.fit = TRUE) 
pred.dd.stock.gam.fish$lam.fish   <- exp(tmp$fit)
pred.dd.stock.gam.fish$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
pred.dd.stock.gam.fish$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)

# Thin the data so I can add points to the figure
tmp <- NULL
for(i in 1:(77)) 
{
  if(i==1) tmp[[i]] <- seq(10,230,length.out=5)
  if(i>1) tmp[[i]] <- seq(10,230,length.out=5)+250*(i-1)
}
thinner.fish <- do.call('c',tmp)
thin.pred.fish <- pred.dd.stock.gam.fish[thinner.fish,]
# Now I want to get rid of extrapolation from this prediction data.frame, I think I need to loop it...
# 
short.stocks <- unique(dd.dat$Stock.short)
pred.out <- NULL
thin.out <- NULL
for(i in short.stocks)
{
  # Get the right stocks
  tmpy <- dd.dat |> collapse::fsubset(Stock.short == i)
  tmp.pred <- pred.dd.stock.gam.fish |> collapse::fsubset(Stock.short == i)
  tmp.thin <- thin.pred.fish |> collapse::fsubset(Stock.short == i)
  # I dont want to predict below the minimum observed abundance
  mins <- min(tmpy$prop.abund,na.rm=T)
  pred.out[[i]] <- tmp.pred |> collapse::fsubset(prop.abund >= mins)
  thin.out[[i]] <- tmp.thin |> collapse::fsubset(prop.abund >= mins)
}

pred.dd.stock.gam.ss.fish <- do.call('rbind',pred.out)
thin.pred.fish <- do.call('rbind',thin.out)
# Combine pred stuff with the meta data for fun plots
pred.dd.stock.gam.ss.fish <- left_join(pred.dd.stock.gam.ss.fish,meta.sub,by="Stock.short")
pred.dd.stock.gam.ss.fish <- data.frame(pred.dd.stock.gam.ss.fish)

thin.pred.fish <- left_join(thin.pred.fish,meta.sub,by="Stock.short")


# Here are the fits (sans SE cause messy + didn't put the overall relationship on here)
# By region

# What proportion of the stocks had the lowest 'GAM' estimate happen when the stock was at it's maximum size.
low.gam <- data.frame(low.pa.fish = NA,diff.low.pa.fish = NA,low.pa.nf = NA,diff.low.pa.nf = NA,Stock = NA,Species = NA)
count <- 0
for(i in short.stocks) 
{
  count = count +1
  tmp <- pred.dd.stock.gam.ss.fish |> collapse::fsubset(Stock.short == i)
  tmp.nf <- pred.dd.stock.gam.ss.nf |> collapse::fsubset(Stock.short == i)
  low.pa <- data.frame(low.pa.fish = tmp$prop.abund[tmp$lam.fish == min(tmp$lam.fish)],
                       diff.low.pa.fish = tmp$lam.fish[tmp$lam.fish == min(tmp$lam.fish)] - tmp$lam.fish[tmp$prop.abund == max(tmp$prop.abund)],
                       low.pa.nf = tmp.nf$prop.abund[tmp.nf$lam.no.fish == min(tmp.nf$lam.no.fish)],
                       diff.low.pa.nf = tmp.nf$lam.no.fish[tmp.nf$lam.no.fish == min(tmp.nf$lam.no.fish)] - tmp.nf$lam.no.fish[tmp.nf$prop.abund == max(tmp.nf$prop.abund)],
                       Stock = i,Species = tmp$G.Species[1])
  low.gam[count,] <- low.pa
}

# Let's compare lambda at minimum, 0.4, and maximum and make a Table
comp.lam.diff <- NULL
comp.lam <- NULL
comp.all.nf <- NULL
comp.all.fish <- NULL
for(i in short.stocks) 
{
  tmp <- pred.dd.stock.gam.ss.fish |> collapse::fsubset(Stock.short == i)
  which.40 <- max(which(tmp$prop.abund <=0.4)) # Some stocks might not have a which 40.
  which.max <- which(tmp$prop.abund ==1)
  which.min <- which(tmp$prop.abund == min(tmp$prop.abund))
  tmp.sub <- tmp[c(which.min,which.40,which.max),]
  comp.all.fish[[i]] <- tmp.sub
  tmp.nf <- pred.dd.stock.gam.ss.nf |> collapse::fsubset(Stock.short == i)
  # I think I'm overkilling as this should be the same was the above witches....
  which.40.nf <- max(which(tmp.nf$prop.abund <=0.4))
  which.max.nf <- which(tmp.nf$prop.abund ==1)
  which.min.nf <- which(tmp.nf$prop.abund ==min(tmp.nf$prop.abund))
  tmp.nf.sub <- tmp.nf[c(which.min.nf,which.40.nf,which.max.nf),]
  comp.all.nf[[i]] <- tmp.nf.sub
  # Now we just want some summaries here I think...
  comp.lam.diff[[i]] <- data.frame(min.abund = min(tmp.sub$prop.abund,na.rm=T),
                              lam.fish.min.40 = tmp$lam.fish[which.min] - tmp$lam.fish[which.40],
                              lam.fish.min.max = tmp$lam.fish[which.min] - tmp$lam.fish[which.max],
                              lam.fish.40.max = tmp$lam.fish[which.40] - tmp$lam.fish[which.max],
                              lam.nf.min.40 = tmp.nf$lam.no.fish[which.min.nf] - tmp.nf$lam.no.fish[which.40.nf],
                              lam.nf.min.max = tmp.nf$lam.no.fish[which.min.nf] - tmp.nf$lam.no.fish[which.max.nf],
                              lam.nf.40.max = tmp.nf$lam.no.fish[which.40.nf] - tmp.nf$lam.no.fish[which.max.nf],
                              Stock = i,Species = tmp$G.Species[1])
  
    comp.lam[[i]] <- data.frame(min.abund = min(tmp.sub$prop.abund,na.rm=T),
                                lam.fish.min = tmp$lam.fish[which.min] ,
                                lam.fish.40 = tmp$lam.fish[which.40],
                                lam.fish.max = tmp$lam.fish[which.max],
                                lam.nf.min = tmp.nf$lam.no.fish[which.min.nf],
                                lam.nf.40 = tmp.nf$lam.no.fish[which.40.nf],
                                lam.nf.max = tmp.nf$lam.no.fish[which.max.nf],
                                Stock = i,Species = tmp$G.Species[1])
}

# A table for the estimates at 'interesting' values
comp.lam.res <- do.call('rbind',comp.lam)
# I want to turn this into a table....
comp.lam.res.tab <- comp.lam.res
# Round the numbers
comp.lam.res.tab$min.abund <- round(comp.lam.res.tab$min.abund,digits=2)
rounders <- c("lam.fish.min","lam.fish.40","lam.fish.max",
              "lam.nf.min","lam.nf.40","lam.nf.max")
comp.lam.res.tab[,rounders]      <- round(comp.lam.res.tab[,rounders] ,digits=3)
# Now give it pretty names
tab.names <- c("Minimum Abundance",
               "$\\lambda_{F>0}^{Min}$",
               "$\\lambda_{F>0}^{40}$",
               "$\\lambda_{F>0}^{Max}$",
               "$\\lambda_{F=0}^{Min}$",
               "$\\lambda_{F=0}^{40}$",
               "$\\lambda_{F=0}^{Max}$",
               "Stock","Species")
names(comp.lam.res.tab) <- tab.names

# Now do the same with the differences
comp.lam.diff.res <- do.call('rbind',comp.lam.diff)
# I want to turn this into a table....
comp.lam.diff.res.tab <- comp.lam.diff.res
# Round the numbers
comp.lam.diff.res.tab$min.abund <- round(comp.lam.diff.res.tab$min.abund,digits=2)
rounders <- c("lam.fish.min.40","lam.fish.min.max","lam.fish.40.max",
                    "lam.nf.min.40","lam.nf.min.max","lam.nf.40.max")
comp.lam.diff.res.tab[,rounders] <- round(comp.lam.diff.res.tab[,rounders] ,digits=3)
# Now give it pretty names
tab.names <- c("Minimum Abundance",
               "$\\lambda_{F>0}^{Min-40}$",
               "$\\lambda_{F>0}^{Min-Max}$",
               "$\\lambda_{F>0}^{40-Max}$",
               "$\\lambda_{F=0}^{Min-40}$",
               "$\\lambda_{F=0}^{Min-Max}$",
               "$\\lambda_{F=0}^{40-Max}$",
               "Stock","Species")
names(comp.lam.diff.res.tab) <- tab.names


# Used for the figure showing the number of stocks that have recovered by year x.
n.dub <- data.frame(years = 1:n.sim.years, count = NA)
for(i in 1:n.sim.years) n.dub$count[i] <- dub.time.summary |> collapse::fsubset(year==i & prop >= 0.75) |> nrow()

# Compare the population recovery with the variance, using 2010 because all stocks have a value at 2010... 
# I'm using the overall lambda sd, so the year doesn't actually matter other than to make sure all stocks are included here
# This is used for the recovery variance figure, is this data good?
# How many of the stocks had doubled by year 20, with 75% being my standard, which is a high standard
dub.p.high <- 0.75
dub.p.low <- 0.5
n.dub.10 <- dub.time.summary |> collapse::fsubset(year==10 & prop >= dub.p.high) |> nrow()
n.dub.20 <- dub.time.summary |> collapse::fsubset(year==20 & prop >= dub.p.high) |> nrow()
# Slow stocks, here we define having a low recovery potential has having < 50% of the simulatoins experience a doubling in size.
slow.20 <- dub.time.summary |> collapse::fsubset(year==20 & prop < dub.p.low) 
prop.rec.20 <- dub.time.summary |> collapse::fsubset(year==20) # the proportion that recovers by year 20
lambda.sds <- res.lambda.fin |> collapse::fsubset(year == 2010)
lam.sd.p.rec <- left_join(prop.rec.20,lambda.sds,by=names(prop.rec.20)[c(1,4:24)]) 
lam.sd.p.rec$prop.cat <- "Moderate"
lam.sd.p.rec$prop.cat[lam.sd.p.rec$prop < dub.p.low] <- "Low"
lam.sd.p.rec$prop.cat[lam.sd.p.rec$prop >= dub.p.high] <- "High"
lam.sd.p.rec$prop.cat <- factor(lam.sd.p.rec$prop.cat,levels=c("Low","Moderate","High"))
```



```{r paper-calcs,include=F,echo=F,message=F,warning=F}

# the lambda calcs
n.stock.dfo <- meta.sub |> collapse::fsubset(Manage.short == "DFO-TRAC") |> nrow()
n.stock.ices <- meta.sub |> collapse::fsubset(Manage.short == "ICES") |> nrow()
n.stock.noaa <- meta.sub |> collapse::fsubset(Manage.short %in% c("AFSC","NEFSC")) |> nrow()
n.age.0 <- meta.sub |> collapse::fsubset(age.min == 0) |> nrow()
n.age.1 <- meta.sub |> collapse::fsubset(age.min == 1) |> nrow()
n.age.2 <- meta.sub |> collapse::fsubset(age.min == 2) |> nrow()
n.age.2.plus <- meta.sub |> collapse::fsubset(age.min >= 2) |> nrow()
n.age.3.plus <- meta.sub |> collapse::fsubset(age.min > 2) |> nrow()
min.year <- min(res.lambda.fin$year)
max.year <- max(res.lambda.fin$year)
stock.ts.len <- res.lambda.fin |> collapse::fgroup_by(Stock.short) |> collapse::fsummarise(n.years = length(year))
mn.ts.len <- round(mean(stock.ts.len$n.years),digits=1)
min.ts.len <- min(stock.ts.len$n.years)
max.ts.len <- max(stock.ts.len$n.years)
num.orders <- length(unique(meta.sub$Order))
num.gads <- meta.sub |> collapse::fsubset(Order == "Gadiformes") |> nrow()
num.pleur <- meta.sub |> collapse::fsubset(Order == "Pleuronectiformes") |> nrow()
num.scorp <- meta.sub |> collapse::fsubset(Order == "Scorpaeniformes ") |> nrow()
num.clup <- meta.sub |> collapse::fsubset(Order == "Clupeiformes") |> nrow()
num.scomb <- meta.sub |> collapse::fsubset(Order == "Scombriformes") |> nrow()
num.perci <- meta.sub |> collapse::fsubset(Order == "Perciformes") |> nrow()

n.st.spec <- meta.sub |> collapse::fgroup_by(Species ) |> collapse::fsummarise(n.stocks = length(Stock)) 
n.st.spec <- n.st.spec[rev(order(n.st.spec$n.stocks)),]
num.cod <- meta.sub |> collapse::fsubset(Species == "morhua") |> nrow()
num.her <- meta.sub |> collapse::fsubset(Species == "harengus") |> nrow()
num.had <- meta.sub |> collapse::fsubset(Species == "aeglefinus") |> nrow()
num.sol <- meta.sub |> collapse::fsubset(Species == "solea") |> nrow()
num.pol <- meta.sub |> collapse::fsubset(Species == "virens") |> nrow()
num.plat <- meta.sub |> collapse::fsubset(Species == "platessa") |> nrow()


n.six <- meta.sub |> collapse::fsubset(Species %in% six.species) |> nrow() 


med.lambda.F0 <- round(median(res.lambda.fin$lam.no.fish),digits=3)
med.r.F0 <- round(median(log(res.lambda.fin$lam.no.fish)),digits=3)*100
med.lambda.F <- round(median(res.lambda.fin$lam.fish),digits=3)
med.r.F <- round(median(log(res.lambda.fin$lam.fish)),digits=3)*100 # median in insensitive to doing median(log(lambda)) or log(median(lamdba)), which makes sense... it's the same point...
mn.lambda.F <- round(mean(res.lambda.fin$lam.fish),digits=2)
# What proportion of the years was lambda < 1 when accounting for fishing
prop.lam.fish.lt.1 <- 100*round(length(which(res.lambda.fin$lam.fish < 1))/nrow(res.lambda.fin),digits=2)
# So if I take the log of the mean of the lambda's I get 0.02, if I take the mean of log(lambda) I get -0.02.  So that's solidly equivocal, but obviously with fishing it is shockingly close to 0 overall
# but also this does make sense really, if it was way less than 0 then everything collapses...
mn.r.F <- round(log(mean(res.lambda.fin$lam.fish)),digits=2) 
# Curious the number of stock in which the mean with fishing is > 1 overall
lambda.by.stock <- res.lambda.fin |> collapse::fgroup_by(Stock.short) |> collapse::fsummarise(mn.lam.nf = mean(lam.no.fish,na.rm=T),
                                                                                              mn.lam.fish = mean(lam.fish,na.rm=T),
                                                                                              med.lam.nf = median(lam.no.fish,na.rm=T),
                                                                                              med.lam.fish = median(lam.fish,na.rm=T),
                                                                                              years.lt.1.nf = length(which(lam.no.fish<1)),
                                                                                              years.lt.1.fish = length(which(lam.fish<1)),
                                                                                              n.years = length(lam.fish))

# Figure out what proportion of the time stocks have a lambda < 1 and what stocks usually have a lambda less than one
prop.lam.lt.1.nf <-   round(100*median(lambda.by.stock$years.lt.1.nf/lambda.by.stock$n.years),digits = 1)    
prop.lam.lt.1.fish <-   round(100*median(lambda.by.stock$years.lt.1.fish/lambda.by.stock$n.years),digits = 1)
prop.usually.lt.1.nf <- round(100*length(which(lambda.by.stock$years.lt.1.nf/lambda.by.stock$n.years >= 0.5)) /n.stocks,digits=1)                        
prop.usually.lt.1.fish <- round(100*length(which(lambda.by.stock$years.lt.1.fish/lambda.by.stock$n.years >= 0.5)) /n.stocks,digits=1)                        

max.median.stock <- lambda.by.stock[lambda.by.stock$med.lam.nf == max(lambda.by.stock$med.lam.nf,na.rm=T),]
max.median.lam.nf <- round(max.median.stock$med.lam.nf,digits=2)
min.median.stock <- lambda.by.stock[lambda.by.stock$med.lam.nf == min(lambda.by.stock$med.lam.nf,na.rm=T),]
min.median.lam.nf <- round(min.median.stock$med.lam.nf,digits=2)                                          
mean.nf.of.min.median.lam.nf <- round(min.median.stock$mn.lam.nf,digits=2)
mean.fish.of.min.median.lam.nf <- round(min.median.stock$mn.lam.fish,digits=2)
num.mn.lambda.fish.lt.1 <- length(which(lambda.by.stock$mn.lam.fish < 1))

# Mean - median...
res.lambda.fin$med.mn.diff.no.fish <- res.lambda.fin$lam.no.fish.med - res.lambda.fin$lam.no.fish.mn
res.lambda.fin$med.mn.diff.fish <- res.lambda.fin$lam.fish.med - res.lambda.fin$lam.fish.mn
# How many stocks had the mean higher than the median
n.mn.higher.med.no.fish <- length(unique(res.lambda.fin$Stock.short[res.lambda.fin$med.mn.diff.no.fish < 0]))
n.mn.higher.med.fish <- length(unique(res.lambda.fin$Stock.short[res.lambda.fin$med.mn.diff.fish < 0]))
low.mn.lambda.stocks <- unique(res.lambda.fin$Stock.short[res.lambda.fin$med.mn.diff.fish > 0])
n.nw.ice <- length(c(grep("NAFO",low.mn.lambda.stocks),grep("Faroe",low.mn.lambda.stocks)))
n.cod.low.mn <- length(grep("morhua",low.mn.lambda.stocks))
n.cod <- length(grep("morhua",Stocks))

# Density dependence related numbers
n.bl.40 <- length(which(!is.na(comp.lam.res$lam.fish.40)))
n.low.40.nf <- length(which(comp.lam.res$lam.nf.40 < 1))
n.low.40.fish <-length(which(comp.lam.res$lam.fish.40 < 1))
low.lam.40.nf <- -round(min(comp.lam.diff.res$lam.nf.40,na.rm=T),digits=3)
low.4.lam.40.nf <- -round(sort(comp.lam.diff.res$lam.nf.40)[4],digits=3)

# If right isn't this interesting!!! And look, 3 cod stocks from around here all say around 0.4 is the worst.  Most interesting...
n.low.lam.at.max.fish <- length(which(low.gam$low.pa.fish == 1))
n.low.lam.at.max.nf <- length(which(low.gam$low.pa.nf == 1))
low.lam.cods <- low.gam[low.gam$low.pa.nf < 1 & low.gam$Species == "G. morhua",]
n.cod.lam.not.at.max.nf <- nrow(low.lam.cods)
pa.low.cod.min <- round(min(low.lam.cods$low.pa.nf),digits=2)
pa.low.cod.max <- round(max(low.lam.cods$low.pa.nf),digits=2)

# more density dependence numbers
pa.lam.nf.at.one <- 100*round(no.stock.gam.nf.dat$prop.abund[min(which(no.stock.gam.nf.dat$fit <0))],digits=2)
pa.lam.fish.at.one <- 100*round(no.stock.gam.fish.dat$prop.abund[min(which(no.stock.gam.fish.dat$fit <0))],digits=2)
# What is the minimum abundance at which we get a 2 with the fishing lambdas.
pa.big.threshold <- 0.65
pa.low.threshold <- 0.8
lam.low.threshold <- 0.8
pa.lam.fish.low.bigs <- round(max(dd.dat$lam.fish[dd.dat$prop.abund >= pa.big.threshold]),digits=2)
pa.lam.nf.low.bigs <- round(rev(sort(dd.dat$lam.no.fish[dd.dat$prop.abund >= pa.big.threshold]))[2],digits =2)
# What proportion of the stocks had large declines overall, and then the proportion when the population was below 30%
dd.dat.high <- dd.dat |> collapse::fsubset(prop.abund >= 0.3)
prop.low.high.abund <- round(length(which(dd.dat.high$lam.fish < lam.low.threshold)) / nrow(dd.dat.high),digits=3)
prop.low.all <- round(length(which(dd.dat$lam.fish < lam.low.threshold)) / nrow(dd.dat),digits=3)
dd.dat.low <- dd.dat |> collapse::fsubset(prop.abund < 0.3)
prop.low.low.abund <- round(length(which(dd.dat.low$lam.fish < lam.low.threshold)) / nrow(dd.dat.low),digits=3)


# Numbers for the paper, lifetime reproductive growth
r0.mn <- round(mean(pop.dam$R0.opt,na.rm=T),digits=1)
r0.med <- round(median(pop.dam$R0.opt,na.rm=T),digits=1)
# And fishing...
r0.mn.fish <- round(mean(pop.dam.fish$R0.opt,na.rm=T),digits=1)
r0.med.fish <- round(median(pop.dam.fish$R0.opt,na.rm=T),digits=1)



# Where are the slow ones from
n.not.dub.20 <- nrow(slow.20)
n.alaska <- length(unique(dub.time.summary$Stock.short[dub.time.summary$Manage.short== "AFSC"]))
n.nwa <- length(unique(dub.time.summary$Stock.short[dub.time.summary$Manage.short %in% c("DFO-TRAC","NEFSC")]))
n.nea <- length(unique(dub.time.summary$Stock.short[dub.time.summary$Manage.short %in% c("ICES")]))
n.nafo.24 <- length(unique(dub.time.summary$Stock.short[dub.time.summary$Area.broad %in% "NAFO 2-4"]))
# Now the don't recover ones...
n.alaska.slow <- length(slow.20$Stock.short[slow.20$Manage.short== "AFSC"])
n.nwa.slow <- length(slow.20$Stock.short[slow.20$Manage.short %in% c("DFO-TRAC","NEFSC")]) # All in NAFO 2-4
n.nea.slow <- length(slow.20$Stock.short[slow.20$Manage.short %in% "ICES"])

prop.slow.alaska <- round(100*n.alaska.slow/n.alaska,digits=0)
prop.slow.n24 <- round(100*n.nwa.slow/n.nafo.24,digits=0)
# standard deviation in which rebuilding time was also above the low category
sd.rebuild.safe <- ceiling(max(lam.sd.p.rec$lam.no.fish.sd[lam.sd.p.rec$prop.cat == "Low"])*100)/100
lam.rebuild.safe <- ceiling(max(lam.sd.p.rec$lam.no.fish.med[lam.sd.p.rec$prop.cat == "Low"])*100)/100


# Need to grab all the per.diff's, which I seem to have dropped
for.diffs <- do.call('rbind',for.tune.summary)
med.per.diff <- round(median(for.diffs$per.diff,na.rm=T),digits=1)
# what is lambda difference, about 6%, but that means the original was 7% higher, so that means we are reducing lambda when optimizing
# If there was 'missing fishing' we are compensating for with this, this is exactly what we'd expect to happen right?
res.lambda.fin$lam.per.diff <- 100*((res.lambda.fin$lam.org.no.fish - res.lambda.fin$lam.no.fish)/ res.lambda.fin$lam.no.fish)
med.lam.per.diff <- round(median(res.lambda.fin$lam.per.diff,na.rm=T),digits=1)
# By stock, can see most are positive, which is in line with missing fishing mortality...
mod.by.stock.lam.pd <- res.lambda.fin |> collapse::fgroup_by(Stock.short) |> collapse::fsummarise(med = median(lam.per.diff,na.rm=T),
                                                                                                  mn = mean(lam.per.diff,na.rm=T))


```



```{r main-figs,include=F,echo=F,message=F,warning=F}

# New lambda plot with the fishing and no fishing beside each other
# This is likely Figure 1



# mat <- matrix(c(2, 2, 2, 2, 2, 2, 2, 2,  2,  2,
#                 3, 3, 3, 3, 3, 3, 5, 5,  5,  5, 
#                 1, 1, 1, 1, 1, 1, 1, 1, NA, NA,
#                 4, 4, 4, 6, 6, 6, 6, NA, NA, NA), 
#                 4, 10, byrow = TRUE)
# new.lam.plt.6 <- ggplot(res.lambda.fin.long.6) + geom_boxplot(aes(y=lambda,interaction(group,Stock.no.species),color=group)) +
#                                            #geom_boxplot(aes(y=lam.no.fish,x=G.Species))  + 
#                                            scale_x_discrete(NULL, guide = "axis_nested") +
#                                            xlab("") + scale_y_log10("Lambda",breaks = log_breaks(n=8),limits=c(0.2,12)) + 
#                                            geom_hline(yintercept = 1,linetype='dashed') +
#                                            facet_manual(vars(G.Species),design=mat,scales='free_x')+
#                                            theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))



## New Figure...

mat <- matrix(c(rep(2,14),
                rep(3,8), rep(NA,1), rep(5,5),
                rep(NA,2),rep(4,4),rep(NA,1),rep(6,5),rep(NA,2),
                rep(NA,2),rep(1,9),rep(NA,3)),
                nrow=14, ncol=4,byrow=F)

new.lam.plt.6 <- ggplot(res.lambda.fin.long.6) + geom_boxplot(aes(x=lambda,interaction(group,Stock.no.species),fill=group,color=group)) +
                                           geom_point(aes(x=med.lam.stock,interaction(group,Stock.no.species)),color="firebrick2",fill="firebrick2",shape=8) +
                                           scale_y_discrete(NULL, guide = "axis_nested") +
                                           scale_color_manual(values = c("grey","blue")) +
                                           scale_fill_manual(values = c("grey",'blue')) +
                                           xlab("") + scale_x_log10("Lambda",breaks = log_breaks(n=8),limits=c(0.2,12)) + 
                                           geom_vline(xintercept = 1,linetype='dashed') +
                                           facet_manual(vars(G.Species),design=mat,scales='free_y')+
                                           theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
                                                 plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Lambda_boxplot_6_species_",what.2.tune,".png"),new.lam.plt.6,base_width = 20,base_height = 10)







# The other stocks, perhaps we put this in a supplement...
# mat <- matrix(c(1, 2, 2, 2, 2, 3, 4, 5,6,NA,NA,
#                 7, 7, rep(8,9),
#                 9, 9, rep(10,7),11,11),
#                 3, 11, byrow = TRUE)
# 
# new.lam.plt.others <- ggplot(res.lambda.fin.long.others) + geom_boxplot(aes(y=lambda,interaction(group,G.Species.short),color=group,fill=group)) +
#                                            #geom_boxplot(aes(y=lam.no.fish,x=G.Species))  + 
#                                            scale_x_discrete(NULL, guide = "axis_nested") +
#                                            xlab("") + scale_y_log10("Lambda",breaks = log_breaks(n=8),limits=c(0.2,12)) + 
#                                            geom_hline(yintercept = 1,linetype='dashed') +
#                                            facet_manual(vars(Area.long),design=mat,scales='free_x')+
#                                            theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))



mat <- matrix(c(rep(NA,1),rep(1,1), rep(2,4), rep(3,1), rep(4,1),rep(5,1),rep(6,1),rep(NA,1),
                rep(7,2),rep(8,9),
                rep(9,2),rep(10,7),rep(11,2)),
                nrow=11, ncol=3,byrow=F)

new.lam.plt.others <- ggplot(res.lambda.fin.long.others) + geom_boxplot(aes(x=lambda,interaction(group,G.Species.short),color=group,fill=group)) +
                                           geom_point(aes(x=med.lam.stock,interaction(group,G.Species.short)),color="firebrick2",fill="firebrick2",shape=8) +
                                           scale_y_discrete(NULL, guide = "axis_nested") +
                                           scale_color_manual(values = c("grey","blue")) +
                                           scale_fill_manual(values = c("grey",'blue')) +
                                           xlab("") + scale_x_log10("Lambda",breaks = log_breaks(n=8),limits=c(0.2,12)) + 
                                           geom_vline(xintercept = 1,linetype='dashed') +
                                           facet_manual(vars(Area.long),design=mat,scales='free_y')+
                                           theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
                                                 plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Lambda_boxplot_other_species_",what.2.tune,".png"),new.lam.plt.others,base_width = 20,base_height = 10)


# # Standard deviation figure
# colrs.sd <- rep(c(rep('blue',4),rep('orange',4),rep('grey',4),rep('black',4)),20)
# pty.sd <- rep(rep(c(21,4,9,8),4),20)
# 
# lam.sd.plt <- ggplot(res.lambda.fin ) + 
#                                        geom_point(aes(y = lam.no.fish.sd,x=G.Species,group=Area.long,color=Area.long,shape = Area.long,fill=Area.long),size=3) +
#                                        scale_y_log10("Standard deviation (Lambda)",log_breaks(n=8)) +
#                                        scale_color_manual(values=colrs.sd) + scale_shape_manual(values = pty.sd) + scale_fill_manual(values=colrs.sd)+
#                                        theme(axis.text.x = element_text(angle =45,hjust=1),
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
# 
# save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Lambda_sd_",what.2.tune,".png"),lam.sd.plt,base_width = 10,base_height = 10)
# 

# New figure....
res.chhp <- res.lambda.fin |> collapse::fsubset(Species %in% c("morhua","aeglefinus","harengus","virens"))

res.chhp$locale <- "Eastern Atlantic"
res.chhp$locale[!res.chhp$Manage.short %in% "ICES"] <- "Western Atlantic"
res.chhp$locale[res.chhp$Area.broad %in% c("Ice-Faroe","NEA")] <- "Northern Atlantic"
res.chhp$locale[res.chhp$Manage.short %in% "AFSC"] <- "Pacific"


res.chhp.summary <- res.chhp |> collapse::fgroup_by(locale,G.Species) |> collapse::fsummarise(avg.sd = mean(lam.no.fish.sd,na.rm=T),
                                                                                 sd.of.sd = sd(lam.no.fish.sd,na.rm=T))
res.chhp.summary$locale <- factor(res.chhp.summary$local,levels = c("Western Atlantic", "Northern Atlantic","Eastern Atlantic"))

colrs.sd <- c("blue","orange","black","firebrick2")

lam.sd.plt <- ggplot(res.chhp.summary,aes(y = avg.sd,x=locale,group=G.Species,color=G.Species)) + 
                                              geom_point(position=position_dodge(width=0.3),size=2) + 
                                              geom_line(position=position_dodge(width=0.3),size=1.25) +
                                              scale_color_manual(values=colrs.sd) + 
                                              geom_errorbar(aes(ymin=avg.sd - sd.of.sd, ymax=avg.sd+sd.of.sd,x=locale),width=0 ,position=position_dodge(width=0.3)) +
                                              xlab("") + ylab("Standard devation (Lambda)") + theme(legend.title = element_blank())
save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Lambda_sd_",what.2.tune,".png"),lam.sd.plt,base_width = 10,base_height = 6)




# Overall density dependence
# MAIN PAPER FIGURE#
dd.nf.overall.plt <-ggplot(no.stock.gam.nf.dat , aes(x=prop.abund,y=exp(fit))) + 
                                geom_point(data = dd.dat,aes(x=prop.abund,y=lam.no.fish),size=2,alpha=0.1) +  
                                geom_ribbon(aes(ymin=exp(LCI),ymax=exp(UCI)),alpha=0.5,linewidth=0,fill=u.colors[1])+
                                geom_line(color=u.colors[1],linewidth=1) + 
                                xlab("") + 
                                scale_y_log10(name = "Lambda(F=0)",breaks = log_breaks(n=10),limits=c(0.2,12)) +
                                geom_hline(yintercept = 1,color='firebrick2',linetype = 'dashed')+
                                theme(legend.text=element_text(size=8),
                                      legend.spacing.y = unit(-0.1, 'cm'),
                                      legend.title = element_blank(),
                                      axis.text.x = element_blank()) + 
                                 guides(color = guide_legend(ncol=1,byrow=T),
                                        shape = guide_legend(ncol=1,byrow=T))



# MAIN PAPER FIGURE#
dd.fish.overall.plt <- ggplot(no.stock.gam.fish.dat, aes(x=prop.abund,y=exp(fit))) + 
                                geom_point(data = dd.dat,aes(x=prop.abund,y=lam.fish),size=2,alpha=0.1) +  
                                geom_line(color=u.colors[2],linewidth=2) + 
                                geom_ribbon(aes(ymin=exp(LCI),ymax=exp(UCI)),alpha=0.5,fill=u.colors[2])+
                                xlab("") + 
                                scale_y_log10(name = "Lambda (F>0)",breaks = log_breaks(n=10),limits=c(0.2,12)) +
                                geom_hline(yintercept = 1,color='firebrick2',linetype = 'dashed',linewidth=1.5)+
                                theme(legend.text=element_text(size=8),
                                      legend.spacing.y = unit(-0.1, 'cm'),
                                      legend.title = element_blank(),
                                      axis.text.x = element_blank()) + 
                                 guides(color = guide_legend(ncol=1,byrow=T),
                                        shape = guide_legend(ncol=1,byrow=T))



# Main Paper Figure Density dependence with and without fishing, effectively a zoomed in version of the above.
colrs <- u.colors
t.smooth <- rbind(no.stock.gam.fish.dat,no.stock.gam.nf.dat)
dd.fish.nf.plt <- ggplot(t.smooth, aes(x=prop.abund,y=exp(fit),group=Scenario,color=Scenario,fill=Scenario)) + 
                                 geom_ribbon(aes(ymin=exp(LCI),ymax=exp(UCI),group=Scenario,fill=Scenario),alpha=0.50,linewidth=0)+
                                 geom_line(linewidth=1.5) +
                                 geom_hline(yintercept = 1,color='firebrick2',linetype = 'dashed')+
                                 scale_fill_manual(values = colrs) + scale_color_manual(values = colrs) +
                                 scale_x_continuous(name = "Proportion of maximum abundance",breaks = seq(0,1,by=0.1)) + 
                                 scale_y_log10(name = "Lambda",breaks = log_breaks(n=8)) +
                                 theme(legend.position = c(0.9,0.75)) 

dd.overall.combo <- plot_grid(dd.nf.overall.plt,dd.fish.overall.plt,dd.fish.nf.plt,nrow=3)


save_plot(paste0(loc,"/Figures/tuned/No_age_correction/density_dependence_overall_",what.2.tune,".png"),dd.overall.combo,base_width = 10,base_height = 10)



# Density dependence by stock 
cols.gam <- rep(c("black","blue","orange",'firebrick2','lightgreen'),6)
pty.gam <- c(rep(0,5),rep(1,5),rep(2,5),rep(3,5),rep(4,5),rep(5,5))
# Doing this manually because the ordered factor wasn't working... annoying...
mat <- matrix(c(2, 2,13,13, 5, 5, 9, 9,
                3, 3,12,12, 6, 6, 8, 8,
               NA,NA,10,10,11,11,NA,NA,
               NA,7, 7, 4, 4, 1, 1, NA),
                4, 8, byrow = TRUE)

dd.stocks.nf.plt <- ggplot(pred.dd.stock.gam.ss.nf,aes(x=prop.abund,y=lam.no.fish,group=Stock.short,color=G.Species,shape=G.Species)) + 
                                geom_line() + 
                                geom_point(data = thin.pred.nf,size=2) +  
                                xlab("Proportion of maximum abundance") + 
                                scale_y_log10(name = "Lambda (F=0)",breaks = log_breaks(n=10)) +
                                geom_ribbon(aes(ymin=lower,ymax=upper,color=G.Species),alpha=0.10,linewidth=0)+
                                facet_manual(vars(Area.long),design=mat,scales='free_x')+
                                #facet_wrap(~Area.long)  +
                                scale_shape_manual(values=pty.gam) +
                                scale_color_manual(values = cols.gam) + 
                                geom_hline(yintercept = 1,color='firebrick2',linetype = 'dashed')+
                                theme(legend.text=element_text(size=8),
                                      legend.spacing.y = unit(-0.1, 'cm'),
                                      legend.title = element_blank(),
                                      axis.text.x = element_text(size=7)) + 
                                 guides(color = guide_legend(ncol=1,byrow=T),
                                        shape = guide_legend(ncol=1,byrow=T))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/density_dependence_nf_stocks_",what.2.tune,".png"),dd.stocks.nf.plt,base_width = 10,base_height = 10)

mat <- matrix(c(2, 2,13,13, 5, 5, 9, 9,
                3, 3,12,12, 6, 6, 8, 8,
               NA,NA,10,10,11,11,NA,NA,
               NA,7, 7, 4, 4, 1, 1, NA),
                4, 8, byrow = TRUE)

# MAIN PAPER FIGURE#
dd.stocks.fish.plt <- ggplot(pred.dd.stock.gam.ss.fish,aes(x=prop.abund,y=lam.fish,group=Stock.short,color=G.Species,shape=G.Species)) + 
                                geom_line() + 
                                geom_point(data = thin.pred.fish,size=2) +  
                                geom_ribbon(aes(ymin=lower,ymax=upper,color=G.Species),alpha=0.10,linewidth=0)+
                                xlab("Proportion of maximum abundance") + 
                                scale_y_log10(name = "Lambda (F>0)",breaks = log_breaks(n=10)) +
                                facet_manual(vars(Area.long),design=mat,scales='free_x')+
                                #facet_wrap(~Area.long)  +
                                scale_shape_manual(values=pty.gam) +
                                scale_color_manual(values = cols.gam) + 
                                geom_hline(yintercept = 1,color='firebrick2',linetype = 'dashed')+
                                theme(legend.text=element_text(size=8),
                                      legend.spacing.y = unit(-0.1, 'cm'),
                                      legend.title = element_blank(),
                                      axis.text.x = element_text(size=7)) + 
                                 guides(color = guide_legend(ncol=1,byrow=T),
                                        shape = guide_legend(ncol=1,byrow=T))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/density_dependence_fish_stocks_",what.2.tune,".png"),dd.stocks.fish.plt,base_width = 10,base_height = 10)


pop.dam <- pop.dam |> collapse::fgroup_by(Stock) |> 
                           collapse::fmutate(med.gen.len = median(gen.len.opt,na.rm=T),med.r0 = median(R0.opt,na.rm=T)) |>
                           as.data.frame()
# Lifetime reproductive success 
mat <- matrix(c(rep(2,14),
                rep(3,8), rep(NA,1), rep(5,5),
                rep(NA,2),rep(4,4),rep(NA,1),rep(6,5),rep(NA,2),
                rep(NA,2),rep(1,9),rep(NA,3)),
                nrow=14, ncol=4,byrow=F)


r0.boxplt.6 <- ggplot(pop.dam.all.6) + geom_boxplot(aes(x=R0.opt,interaction(group,Stock.no.species),fill=group,color=group)) +
                                           geom_point(aes(x=med.r0,interaction(group,Stock.no.species)),color="firebrick2",fill="firebrick2",shape=8) +
                                           scale_y_discrete(NULL, guide = "axis_nested") +
                                           scale_color_manual(values = c("grey","blue")) +
                                           scale_fill_manual(values = c("grey",'blue')) +
                                       #scale_x_discrete(NULL, guide = "axis_nested") + 
                                        scale_x_log10(name = "Lifetime Reproductive Output")+
                                       geom_vline(xintercept = 1,linetype='dashed',color='blue')+
                                       facet_manual(vars(G.Species),design=mat,scales='free_y')+
                                           theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
                                                 plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/R0_boxplot_6_species_",what.2.tune,".png"),r0.boxplt.6,base_width = 20,base_height = 10)

mat <- matrix(c(rep(NA,1),rep(1,1), rep(2,4), rep(3,1), rep(4,1),rep(5,1),rep(6,1),rep(NA,1),
                rep(7,2),rep(8,9),
                rep(9,2),rep(10,7),rep(11,2)),
                nrow=11, ncol=3,byrow=F)

r0.boxplot.others <- ggplot(pop.dam.all.others) +   geom_boxplot(aes(x=R0.opt,interaction(group,G.Species.short),fill=group,color=group)) +
                                                   geom_point(aes(x=med.r0,interaction(group,G.Species.short)),color="firebrick2",fill="firebrick2",shape=8) +
                                                   scale_y_discrete(NULL, guide = "axis_nested") +
                                                   scale_color_manual(values = c("grey","blue")) +
                                                   scale_fill_manual(values = c("grey",'blue')) +
                                                    #scale_x_discrete(NULL, guide = "axis_nested") + 
                                                    scale_x_log10(name = "Lifetime Reproductive Output")+
                                                    geom_vline(xintercept = 1,linetype='dashed',color='blue')+
                                                    facet_manual(vars(Area.long),design=mat,scales='free_y')+
                                                    theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
                                                          plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/R0_boxplot_other_species_",what.2.tune,".png"),r0.boxplot.others,base_width = 20,base_height = 10)




r0.heatmap.ne <- ggplot(pop.dam |> collapse::fsubset(LME == "NE Atlantic"), aes(x=cohort, y=Stock.short, fill= R0.opt)) + 
                                    xlab("") + ylab("")+
                                    facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + 
                                    geom_tile() + 
                                     scale_fill_viridis(name = "Lifetime reproductive success", breaks = c(0.4,1,2,4,10,20,40,100,200,400),
                                                        discrete=FALSE,trans='log') + 
                                    theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.9, "cm"))

r0.heatmap.nw <- ggplot(pop.dam |> collapse::fsubset(LME == "NW Atlantic"), aes(x=cohort, y=Stock.short, fill= R0.opt)) + 
                                    xlab("") + ylab("")+
                                    facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                                    geom_tile() + 
                                     scale_fill_viridis(name = "Lifetime reproductive success", breaks = c(0.4,1,2,4,10,20,40,100,200,400),
                                                        discrete=FALSE,trans='log') + 
                                    theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,1.22, "cm"))

r0.heatmap.pac <- ggplot(pop.dam |> collapse::fsubset(LME == "Pacific (Alaska)"), aes(x=cohort, y=Stock.short, fill= R0.opt)) + 
                                     xlab("") + ylab("")+
                                     facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                                     geom_tile() + 
                                     scale_fill_viridis(name = "Lifetime reproductive success", breaks = c(0.4,1,2,4,10,20,40,100,200,400),
                                                        discrete=FALSE,trans='log') + 
                                     theme(legend.position = 'top',text = element_text(size=12),plot.margin = margin(0,0.5,0,0, "cm"),
                                           legend.key.width = unit(3,'cm'))

r0.heatmap <- cowplot::plot_grid(r0.heatmap.pac,r0.heatmap.nw,r0.heatmap.ne,nrow = 3,rel_heights = c(3,4,10))


save_plot(paste0(loc,"/Figures/tuned/No_age_correction/r0_heatmap_nf_",what.2.tune,".png"),r0.heatmap,base_width = 20,base_height = 17)




r0.heatmap.ne.fish <- ggplot(pop.dam.fish |> collapse::fsubset(LME == "NE Atlantic"), aes(x=cohort, y=Stock.short, fill= R0.opt)) + 
                                    xlab("") + ylab("")+
                                    facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + 
                                    geom_tile() + 
                                     scale_fill_viridis(name = "Lifetime reproductive success", breaks = c(0.4,1,2,4,10,20,40,100,200,400),
                                                        discrete=FALSE,trans='log') + 
                                    theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.9, "cm"))

r0.heatmap.nw.fish <- ggplot(pop.dam.fish |> collapse::fsubset(LME == "NW Atlantic"), aes(x=cohort, y=Stock.short, fill= R0.opt)) + 
                                    xlab("") + ylab("")+
                                    facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                                    geom_tile() + 
                                     scale_fill_viridis(name = "Lifetime reproductive success", breaks = c(0.4,1,2,4,10,20,40,100,200,400),
                                                        discrete=FALSE,trans='log') + 
                                    theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,1.22, "cm"))

r0.heatmap.pac.fish <- ggplot(pop.dam.fish |> collapse::fsubset(LME == "Pacific (Alaska)"), aes(x=cohort, y=Stock.short, fill= R0.opt)) + 
                                     xlab("") + ylab("")+
                                     facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                                     geom_tile() + 
                                     scale_fill_viridis(name = "Lifetime reproductive success", breaks = c(0.4,1,2,4,10,20,40,100,200,400),
                                                        discrete=FALSE,trans='log') + 
                                     theme(legend.position = 'top',text = element_text(size=12),plot.margin = margin(0,0.5,0,0, "cm"),
                                           legend.key.width = unit(3,'cm'))

r0.heatmap.fish <- cowplot::plot_grid(r0.heatmap.pac.fish,r0.heatmap.nw.fish,r0.heatmap.ne.fish,nrow = 3,rel_heights = c(3,4,10))


save_plot(paste0(loc,"/Figures/tuned/No_age_correction/r0_heatmap_fish_",what.2.tune,".png"),r0.heatmap.fish,base_width = 20,base_height = 17)





# Generation length
mat <- matrix(c(rep(2,14),
                rep(3,8), rep(NA,1), rep(5,5),
                rep(NA,2),rep(4,4),rep(NA,1),rep(6,5),rep(NA,2),
                rep(NA,2),rep(1,9),rep(NA,3)),
                nrow=14, ncol=4,byrow=F)


r0.boxplt.6 <- ggplot(pop.dam.all.6) + geom_boxplot(aes(x=R0.opt,interaction(group,Stock.no.species),fill=group,color=group)) +
                                           geom_point(aes(x=med.r0,interaction(group,Stock.no.species)),color="firebrick2",fill="firebrick2",shape=8) +
                                           scale_y_discrete(NULL, guide = "axis_nested") +
                                           scale_color_manual(values = c("grey","blue")) +
                                           scale_fill_manual(values = c("grey",'blue')) +
                                       #scale_x_discrete(NULL, guide = "axis_nested") + 
                                        scale_x_log10(name = "Lifetime Reproductive Output")+
                                       geom_vline(xintercept = 1,linetype='dashed',color='blue')
  
gen.boxplt.6 <- ggplot(pop.dam.all.6) + geom_boxplot(aes(x=gen.len.opt,interaction(group,Stock.no.species),fill=group,color=group)) +
                                        geom_point(aes(x=med.gen.len,interaction(group,Stock.no.species)),color="firebrick2",fill="firebrick2",shape=8) +
                                        scale_y_discrete(NULL, guide = "axis_nested") +
                                        scale_color_manual(values = c("grey","blue")) +
                                        scale_fill_manual(values = c("grey",'blue')) +
                                        scale_x_continuous("Generation Length (years)",limits=c(0,13),breaks= seq(0,20,by=2)) +
                                        facet_manual(vars(G.Species),design=mat,scales='free_y')+
                                         theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
                                               plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
                            

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/GL_boxplot_6_species_",what.2.tune,".png"),gen.boxplt.6,base_width = 20,base_height = 10)

# Then the generation length for others.
mat <- matrix(c(rep(NA,1),rep(1,1), rep(2,4), rep(3,1), rep(4,1),rep(5,1),rep(6,1),rep(NA,1),
                rep(7,2),rep(8,9),
                rep(9,2),rep(10,7),rep(11,2)),
                nrow=11, ncol=3,byrow=F)

gen.boxplt.others <- ggplot(pop.dam.all.others) + geom_boxplot(aes(x=gen.len.opt,interaction(group,G.Species.short),fill=group,color=group)) +
                                                  geom_point(aes(x=med.gen.len,interaction(group,G.Species.short)),color="firebrick2",fill="firebrick2",shape=8) +
                                                  scale_y_discrete(NULL, guide = "axis_nested") +
                                                  scale_color_manual(values = c("grey","blue")) +
                                                  scale_fill_manual(values = c("grey",'blue')) +
                                                  scale_x_continuous("Generation Length (years)",limits=c(0,13),breaks= seq(0,20,by=2)) +
                                                  facet_manual(vars(Area.long),design=mat,scales='free_y')+
                                                  theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
                                                        plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/GL_boxplot_other_species_",what.2.tune,".png"),gen.boxplt.others,base_width = 20,base_height = 10)




gen.heatmap.ne <- ggplot(pop.dam |> collapse::fsubset(LME == "NE Atlantic"), aes(x=cohort, y=Stock.short, fill= gen.len.opt)) + 
                                              xlab("") + ylab("")+  
                                              facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + 
                                              geom_tile() + scale_fill_viridis(name = "Generation length (years)",discrete=FALSE) + 
                                              theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.9, "cm"))

gen.heatmap.nw <- ggplot(pop.dam |> collapse::fsubset(LME == "NW Atlantic"), aes(x=cohort, y=Stock.short, fill= gen.len.opt)) + xlab("") + ylab("")+                                    facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Generation length (years)",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,1.22, "cm"))

gen.heatmap.pac <- ggplot(pop.dam |> collapse::fsubset(LME == "Pacific (Alaska)"), aes(x=cohort, y=Stock.short, fill= gen.len.opt)) + xlab("") + ylab("")+
                            facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Generation length (years)",discrete=FALSE) + 
                            theme(legend.position = 'top',text = element_text(size=12),plot.margin = margin(0,0.5,0,0, "cm"),
                                  legend.key.width = unit(3,'cm'))

gen.heatmap <- cowplot::plot_grid(gen.heatmap.pac,gen.heatmap.nw,gen.heatmap.ne,nrow = 3,rel_heights = c(3,4,10))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/GL_heatmap_nf_",what.2.tune,".png"),gen.heatmap,base_width = 15,base_height = 10)


gen.heatmap.ne.fish <- ggplot(pop.dam.fish |> collapse::fsubset(LME == "NE Atlantic"), aes(x=cohort, y=Stock.short, fill= gen.len.opt)) + 
                                              xlab("") + ylab("")+  
                                              facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + 
                                              geom_tile() + scale_fill_viridis(name = "Generation length (years)",discrete=FALSE) + 
                                              theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.9, "cm"))

gen.heatmap.nw.fish <- ggplot(pop.dam.fish |> collapse::fsubset(LME == "NW Atlantic"), aes(x=cohort, y=Stock.short, fill= gen.len.opt)) + xlab("") + ylab("")+                                    facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Generation length (years)",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,1.22, "cm"))

gen.heatmap.pac.fish <- ggplot(pop.dam.fish |> collapse::fsubset(LME == "Pacific (Alaska)"), aes(x=cohort, y=Stock.short, fill= gen.len.opt)) + xlab("") + ylab("")+
                            facet_wrap(~LME,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Generation length (years)",discrete=FALSE) + 
                            theme(legend.position = 'top',text = element_text(size=12),plot.margin = margin(0,0.5,0,0, "cm"),
                                  legend.key.width = unit(3,'cm'))

gen.heatmap.fish <- cowplot::plot_grid(gen.heatmap.pac.fish,gen.heatmap.nw.fish,gen.heatmap.ne.fish,nrow = 3,rel_heights = c(3,4,10))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/GL_heatmap_fish_",what.2.tune,".png"),gen.heatmap.fish,base_width = 15,base_height = 10)



dub.time.summary <- dub.time.summary |> collapse::fsubset(year %in% 1:50) |>
                            collapse::roworder(G.Species,LME,Area.broad) |>
                            collapse::fmutate(Stock.short = forcats::fct_inorder(factor(Stock.short, ordered=TRUE)))
              
dub.heatmap.gad <- ggplot(dub.time.summary |> collapse::fsubset(Order == "Gadiformes"), aes(x=year, y=Stock.short, fill= prop)) + 
                            xlab("") + ylab("")+                                    
                            facet_wrap(~Order.short,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
                            theme(legend.position = 'top',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.45, "cm"),
                                  legend.key.width = unit(3,'cm'))

dub.heatmap.pl <- ggplot(dub.time.summary |> collapse::fsubset(Order == "Pleuronectiformes"), aes(x=year, y=Stock.short, fill= prop)) + 
                            xlab("") + ylab("")+                                    
                            facet_wrap(~Order.short,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0, "cm"))

dub.heatmap.cl <- ggplot(dub.time.summary |> collapse::fsubset(Order == "Clupeiformes"), aes(x=year, y=Stock.short, fill= prop)) + 
                            xlab("") + ylab("")+
                            facet_wrap(~Order.short,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,1.35, "cm"),
                                  legend.key.width = unit(3,'cm'))

dub.heatmap.per <- ggplot(dub.time.summary |> collapse::fsubset(Order == "Perciformes"), aes(x=year, y=Stock.short, fill= prop)) + 
                            xlab("") + ylab("")+
                            facet_wrap(~Order.short,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,2, "cm"),
                                  legend.key.width = unit(3,'cm'))

dub.heatmap.scom <- ggplot(dub.time.summary |> collapse::fsubset(Order == "Scombriformes"), aes(x=year, y=Stock.short, fill= prop)) + 
                            xlab("") + ylab("")+
                            facet_wrap(~Order.short,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
                            geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,2.1, "cm"),
                                  legend.key.width = unit(3,'cm'))

dub.heatmap.scorp <- ggplot(dub.time.summary |> collapse::fsubset(Order %in% "Scorpaeniformes "), aes(x=year, y=Stock.short, fill= prop)) + 
                            xlab("") + ylab("")+
                            facet_wrap(~Order.short,nrow=3,scales='free_y',strip.position = "right") + 
                            geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
                            theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.5, "cm"),
                                  legend.key.width = unit(3,'cm'))



dub.heatmap <- cowplot::plot_grid(dub.heatmap.gad,dub.heatmap.pl,dub.heatmap.cl,dub.heatmap.per,dub.heatmap.scom,dub.heatmap.scorp,
                                  nrow = 6,rel_heights = c(39,20,11,4,3,3))

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Doubling_time_heatmap_by_order_",what.2.tune,".png"),dub.heatmap,base_width = 20,base_height = 20)



# Doubling Time Figure 1
dub.ts.plt <- ggplot(n.dub,aes(x=years,y=count)) + 
                    geom_line() + 
                    geom_hline(yintercept = length(Stocks),linetype="dashed") + 
                    xlab("") + ylab("Number of Stocks")

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Doubling_time_time_series_",what.2.tune,".png"),dub.ts.plt,base_width = 10,base_height = 10)

# Doubling time and variability

colrs.cat <- c("firebrick2","white","blue")
# Can I show this thing better?
lam.sd.p.rec.ordered <- lam.sd.p.rec[order(lam.sd.p.rec$prop.cat,lam.sd.p.rec$lam.no.fish.sd,lam.sd.p.rec$lam.no.fish.med,lam.sd.p.rec$Stock),]
lam.sd.p.rec.ordered$Stock <- factor(lam.sd.p.rec.ordered$Stock,levels =rev(lam.sd.p.rec.ordered$Stock))


lam.sd.p.rec.ordered$lme.short <- "NWA"
lam.sd.p.rec.ordered$lme.short[lam.sd.p.rec.ordered$LME == "NE Atlantic"] <- "NEA"
lam.sd.p.rec.ordered$lme.short[lam.sd.p.rec.ordered$LME == "Pacific (Alaska)"] <- "Pac"
lam.sd.p.rec.ordered$spec.lme <- paste0(lam.sd.p.rec.ordered$G.Species," (",lam.sd.p.rec.ordered$lme.short,")")



p1 <- ggplot(lam.sd.p.rec.ordered) + geom_bar(aes(x=lam.no.fish.med,y=Stock,group = prop.cat,fill=prop.cat,color=prop.cat),stat='identity') + 
                                     scale_y_discrete("",position='right',breaks = NULL) +
                                     scale_fill_manual(values=colrs.cat) +
                                     scale_color_manual(values=rep('black',3)) +
                                     geom_vline(xintercept =1,linetype = 'dashed') + scale_x_reverse("Median lambda") +
                                     theme(legend.position = 'none',
                                           plot.margin = margin(t=53,b=8,l=5),)

p2 <- ggplot(lam.sd.p.rec.ordered) + geom_bar(aes(x=lam.no.fish.sd,y=Stock,group = prop.cat,fill=prop.cat,color=prop.cat),stat='identity')  + 
                                     theme(legend.position = 'top',legend.title = element_blank()) + scale_x_continuous("Standard deviation (lambda)") +
                                     scale_y_discrete("",position='left',labels = rev(lam.sd.p.rec.ordered$spec.lme)) + 
                                     scale_fill_manual(values=colrs.cat) +
                                     scale_color_manual(values=rep('black',3)) +
                                     theme(axis.text.y = element_text(hjust=0.5),
                                           plot.margin = margin(t=53,l=-30,b=8),
                                           axis.ticks.y = element_blank(),
                                           legend.position = c(-0.3,1.02),legend.direction = 'horizontal',)

p3 <- cowplot::plot_grid(p1,p2)
p3

save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Doubling_time_sd_effects_",what.2.tune,".png"),p3,base_width = 11,base_height = 15)


# Is there a relationship between median and sd?
# pts.cat <- 21:23
# sd.rec.plt <- ggplot(lam.sd.p.rec, aes(y=lam.no.fish.med,x=lam.no.fish.sd,color=prop.cat,group=prop.cat)) +
#                        geom_point(size =3,aes(shape=prop.cat,fill=prop.cat)) +
#                        geom_hline(yintercept=1,linetype="dashed") +
#                        scale_y_continuous(name="median Lambda") + scale_x_continuous(name="standard deviation Lambda") +
#                        scale_color_manual(values=colrs.cat) + scale_fill_manual(values=colrs.cat) +
#                        scale_shape_manual(values=pts.cat) + theme(legend.title = element_blank())



```





```{r the-others,include=F,echo=F,message=F,warning=F}
#             
# 
# dub.heatmap.cod <- ggplot(dub.time.6 |> collapse::fsubset(G.Species == "G. morhua"), aes(x=year, y=Stock.no.species, fill= prop)) + xlab("") + ylab("")+                                     facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + 
#                             geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + scale_x_continuous(labels=NULL) +
#                             theme(legend.position = 'top',text = element_text(size=12),plot.margin = margin(0,0.5,0,0, "cm"),
#                                   legend.key.width = unit(3,'cm'))
# 
# dub.heatmap.herring<- ggplot(dub.time.6 |> collapse::fsubset(G.Species == "C. harengus"), aes(x=year, y=Stock.no.species, fill= prop)) + 
#                               xlab("") + ylab("")+                                    
#                               facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
#                               geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
#                               theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.4, "cm"))
# 
# dub.heatmap.haddock<- ggplot(dub.time.6 |> collapse::fsubset(G.Species == "M. aeglefinus"), aes(x=year, y=Stock.no.species, fill= prop)) + 
#                               xlab("") + ylab("")+                                    
#                               facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
#                               geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
#                               theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.125, "cm"))
# 
# dub.heatmap.virens<- ggplot(dub.time.6 |> collapse::fsubset(G.Species == "P. virens"), aes(x=year, y=Stock.no.species, fill= prop)) + 
#                               xlab("") + ylab("")+                                    
#                               facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
#                               geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
#                               theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,1.4, "cm"))
# 
# dub.heatmap.solea<- ggplot(dub.time.6 |> collapse::fsubset(G.Species == "S. solea"), aes(x=year, y=Stock.no.species, fill= prop)) + 
#                               xlab("") + ylab("")+                                    
#                               facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous(labels=NULL) +
#                               geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
#                               theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.4, "cm"))
# 
# dub.heatmap.platessa<- ggplot(dub.time.6 |> collapse::fsubset(G.Species == "P. platessa"), aes(x=year, y=Stock.no.species, fill= prop)) + 
#                               xlab("") + ylab("")+                                    
#                               facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + scale_x_continuous() +
#                               geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
#                               theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.68, "cm"))
# 
# 
# 
# dub.heatmap.sp6 <- cowplot::plot_grid(dub.heatmap.cod,dub.heatmap.herring,dub.heatmap.haddock,
#                                  dub.heatmap.virens, dub.heatmap.solea,dub.heatmap.platessa,nrow = 6,rel_heights = c(14,9,8,5,5,4))
# dub.heatmap.sp6
# 
# save_plot(paste0(loc,"/Figures/tuned/No_age_correction/Doubling_time_heatmap_by_sp6_",what.2.tune,".png"),dub.heatmap.sp6,base_width = 20,base_height = 17)
# 
# 
# # What about a plot of the sd of lamda by stock
# #colrs.sd <- rep(rep(c("black","blue","orange",'grey'),3),20)
# #pty.sd <- rep(c(rep(21,4),rep(4,4),rep(9,4)),20)
# 
# 
# # Same plot for the not 6 species
# 
# # lam.sd.other.plt <- ggplot(res.lambda.fin |> collapse::fsubset(!Species %in% six.species)) + 
# #                                        geom_point(aes(y = lam.no.fish.sd,x=G.Species,group=Area.long,color=Area.long,shape = Area.long,fill=Area.long),size=3) +
# #                                        scale_y_log10("sd(lambda)",limits=c(0.05,1.5)) +
# #                                        scale_color_manual(values=colrs.sd) + scale_shape_manual(values = pty.sd) + scale_fill_manual(values=colrs.sd)+
# #                                        theme(axis.text.x = element_text(angle =45,hjust=1),
# #                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
# # lam.sd.other.plt
# 
# 
# 
# 
# # Doubling Times
# 
# 
# # Generation length
# 
# # Main text figure!!
# new.lam.plt.6 <- ggplot(res.lambda.fin.long.6) + geom_boxplot(aes(y=lambda,interaction(group,Area.long),color=group)) +
#                                            #geom_boxplot(aes(y=lam.no.fish,x=G.Species))  + 
#                                            scale_x_discrete(NULL, guide = "axis_nested") +
#                                            xlab("") + scale_y_log10("lambda",breaks = c(0.1,0.4,0.6,0.8,1,1.25,1.75,3,5,10),limits=c(0.4,10)) + 
#                                            geom_hline(yintercept = 1,linetype='dashed') +
#                                            facet_wrap(~G.Species,scales='free')+
#                                            theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
# 
# # The other stocks, plotting these by area
# # Main Text FIGURE!
# # More data
# 
# 
# ################### Supplemental Figures################### Supplemental Figures################### Supplemental Figures################### Supplemental 
# 
# 
# 
# # Time series of lambdas....
# col.try <- rep(rep(c("black","blue","orange",'firebrick2','lightgreen'),3),20)
# #col.try <- rep(c(rep("black",3),rep("blue",3),rep('orange',3),rep('firebrick2',3),rep('lightgreen',3)),20)
# pty <- rep(c(rep(21,5),rep(22,5),rep(23,5)),20)
# #pty <- rep(rep(c(21:23),5),20)
# 
# lambda.ts.plt <- ggplot(res.lambda.final.6,aes(y=lam.fish,x=year,group=Stock.short,color=Stock.short,shape = Stock.short,fill = Stock.short)) +
#                             geom_point(size=4) +
#                             geom_smooth(method='gam',formula = y ~ s(x, bs = "cs", fx = TRUE, k = 5),se=F) + 
#                             #scale_y_log10(name = "lambda") +
#                             facet_wrap(~G.Species,scales='free_y') +
#                             scale_color_manual(name = "Stock",values = col.try) + scale_shape_manual(name = "Stock",values = pty) +
#                             scale_fill_manual(name = "Stock",values = col.try)+
#                             guides(colour = guide_legend(ncol = 1))+
#                             theme(axis.text.x = element_text(angle =45,hjust=1),legend.key.width = unit(5,'cm'))
# #lambda.ts.plt
# save_plot(paste0(loc,"/Figures/tuned/No_age_correction/lambda_timeseries_6_",what.2.tune,".png"),lambda.ts.plt,base_width = 12,base_height = 10)
# 
# 
# lambda.dec.plt <- ggplot(res.lambda.final.6,aes(y=med.lam,x=as.factor(decade))) +
#                             geom_boxplot() + scale_y_log10()+
#                             xlab("Decade") + ylab("Lambda") + 
#                             geom_point(aes(x=as.factor(decade),y=lm.spec.mn),color='blue',shape=8,fill='blue')+
#                             #scale_x_continuous(breaks=seq(1940,2020,by=10))+
#                             geom_hline(yintercept = 1,linetype='dashed') +
#                             facet_wrap(~G.Species,scales='free_y') 
# save_plot(paste0(loc,"/Figures/tuned/No_age_correction/lambda_by_decade_6_",what.2.tune,".png"),lambda.dec.plt,base_width = 12,base_height = 12)
# 
# 




# ggplot(dd.dat) + geom_point(aes(x=prop.abund,y=lam.no.fish-1)) + xlab("Proportion of Maximum Abundance") + ylab("r (no fishing)")
# 
# # Density dependence by Species
# ggplot(dd.dat,aes(x=prop.abund,y=lam.no.fish,color=Species,group=Species)) + geom_point() + 
#                                                    geom_smooth(method="gam") + 
#                                                    geom_hline(yintercept = 1,linewidth=2,linetype='dashed',color='blue') +
#                                                    scale_x_continuous(name = "Proportion of Maximum Abundance", breaks = seq(0,1,by=0.1))+
#                                                    scale_y_log10(name = "lambda (no fishing)", breaks = c(0.5,0.75,1,1.5,2.5,3.5,5,7.5,10,12.5)) #+
#                                                    #scale_color_manual(values = colrs)
# # Density dependence by stock
# ggplot(dd.dat,aes(x=prop.abund,y=lam.no.fish,color=Stock.short,group=Stock.short)) + geom_point() + 
#                                                    geom_smooth(method="lm",se = F) + 
#                                                    geom_hline(yintercept = 1,linewidth=2,linetype='dashed',color='blue') +
#                                                    scale_x_continuous(name = "Proportion of Maximum Abundance", breaks = seq(0,1,by=0.1))+
#                                                    scale_y_log10(name = "lambda (no fishing)", limits=c(0.4,2),
#                                                                  breaks = seq(0.4,2,by=0.1)) +
#                                                    theme(legend.position = 'none')
# 
# 
# 
# 
# ggplot(dd.dat.no.bigs,aes(x=prop.abund,y=lam.no.fish)) + geom_point() + 
#                                                     geom_smooth(method="gam") + 
#                                                    geom_hline(yintercept = 1,linewidth=2,linetype='dashed',color='blue') +
#                                                    scale_x_continuous(name = "Proportion of Maximum Abundance", breaks = seq(0,1,by=0.1))+
#                                                    scale_y_continuous(name = "lambda (no fishing)")
# 
# ggplot(dd.dat.no.bigs,aes(x=prop.abund,y=lam.no.fish,group=Stock.short,color=Stock.short)) + geom_point() + 
#                                                     geom_smooth(method="lm",se=F) + 
#                                                    geom_hline(yintercept = 1,linewidth=2,linetype='dashed',color='blue') +
#                                                    scale_x_continuous(name = "Proportion of Maximum Abundance", breaks = seq(0,2,by=0.1))+
#                                                    scale_y_log10(name = "lambda (no fishing)")
# 
# 
# # how about our big 6
# colrs <- c("blue","black","firebrick2","orange",'grey50','grey90')
# ggplot(dd.dat.six,aes(x=prop.abund,y=lam.no.fish,color=Species,group=Species)) + geom_point() + 
#                                                     geom_smooth(method="gam") + 
#                                                    geom_hline(yintercept = 1,linewidth=2,linetype='dashed',color='blue') +
#                                                    scale_x_continuous(name = "Proportion of Maximum Abundance", breaks = seq(0,1,by=0.1))+
#                                                    scale_y_log10(name = "lambda (no fishing)", breaks = c(0.5,0.75,1,1.5,2.5,3.5,5,7.5,10,12.5)) +
#                                                    scale_color_manual(values = colrs)
# 
# 
# ggplot(dd.dat.six.no.bigs,aes(x=prop.abund,y=lam.no.fish-1,color=Species,group=Species)) + geom_point() + 
#                                                     geom_smooth(method="gam") + 
#                                                    geom_hline(yintercept = 0,linewidth=2,linetype='dashed',color='blue') +
#                                                    scale_x_continuous(name = "Proportion of Maximum Abundance", breaks = seq(0,1,by=0.1))+
#                                                    scale_y_continuous(name = "r (no fishing)", breaks = seq(-1,1,by=0.2)) +
#                                                    scale_color_manual(values = colrs)

# Other things I did just randomly scattered here


# 
# #hmm <- merge(tst,res.lambda.final.6,by="Stock")
# plot(res.lambda.fin$lam.fish.med ~ res.lambda.fin$lam.fish.mn)
# # So this is lambda with fishing included
# lambda.plt <- ggplot(res.lambda.final.6) + geom_boxplot(aes(y=lam.no.fish,x=Stock.no.species))  + 
#                                            geom_point(aes(y=lam.no.fish.mn,x=Stock.no.species),color='blue',shape=8,fill='blue') +
#                                            xlab("") + scale_y_log10("lambda",breaks = c(0.1,0.4,0.6,0.8,1,1.25,1.75,3,5,10),limits=c(0.4,10)) + 
#                                            geom_hline(yintercept = 1,linetype='dashed') +
#                                            facet_wrap(~G.Species,scales='free')+
#                                            theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
# 
# save_plot(paste0(loc,"/Figures/tuned/No_age_correction/lambda_no_fishing_6_",what.2.tune,".png"),lambda.plt,base_width = 12,base_height = 10)
# 
# # With fishing
# lambda.plt.fish <- ggplot(res.lambda.final.6) + geom_boxplot(aes(y=lam.fish,x=Stock.no.species))  + 
#                                            geom_point(aes(y=lam.fish.mn,x=Stock.no.species),color='blue',shape=8,fill='blue') +
#                                            xlab("") + scale_y_log10("lambda",breaks = c(0.4,0.6,0.8,1,1.25,1.75,3,5,10),limits=c(0.4,10)) + 
#                                            geom_hline(yintercept = 1,linetype='dashed') +
#                                            facet_wrap(~G.Species,scales='free')+
#                                            theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
# 
# 
# save_plot(paste0(loc,"/Figures/tuned/No_age_correction/lambda_with_fishing_6_",what.2.tune,".png"),lambda.plt.fish,base_width = 12,base_height = 10)
# 
# 
# 
# new.lam.plt <- ggplot(res.lambda.fin.long) + geom_boxplot(aes(y=lambda,interaction(group,Order),color=group)) +
#                                            #geom_boxplot(aes(y=lam.no.fish,x=G.Species))  + 
#                                            scale_x_discrete(NULL, guide = "axis_nested") +
#                                            #xlab("") + scale_y_log10("lambda",breaks = c(0.1,0.4,0.6,0.8,1,1.25,1.75,3,5,10),limits=c(0.4,10)) + 
#                                            #geom_hline(yintercept = 1,linetype='dashed') +
#                                            facet_wrap(~Area.long,scales='free')+
#                                            theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none',
#                                                  plot.margin = margin(0,0.5,0,0.5, "cm"),axis.title.y = element_text(margin = margin(r = 30)))
# 
# 
# # The final option I have is to do what I did before and use the bin props
# We can then do a much more ANOVA kinda analysis, drat this doesn't converge..., estimate the 
#mod.dd.bins.stock <- glmer(lam.no.fish ~ prop.bin + (1+prop.bin|Stock),data=dd.dat,family=gaussian(link='log'))
# so go to lmer and log transform... and it is a singular fit
#mod.dd.bins.stock <- lmer(lam.no.fish ~ prop.bin + (1+prop.bin|Stock),data=dd.dat)
# So is an intercept model of any real use?
# mod.dd.bins.stock <- lmer(log(lam.no.fish) ~ prop.bin + (1+prop.bin|Stock.short),data=dd.dat)
# # A non-random effect model does work with the interaction... I'd much rather lmer....
# #mod.dd.bins.stock <- lm(lam.no.fish ~ prop.bin*Stock,data=dd.dat)
# summary(mod.dd.bins.stock)
# #Residuals, nah, still suck, just some crazy outliers...
# plot(mod.dd.bins.stock)
# # Normality = terrible...
# qqnorm(residuals(mod.dd.bins.stock))
# qqline(residuals(mod.dd.bins.stock))
# # So we can predict this ANOVA thing...
# pred.dd.stock.bins <- expand.grid(prop.bin = unique(dd.dat$prop.bin),
#                                          #Species=unique(dd.dat$Species),
#                                          Stock.short=unique(dd.dat$Stock.short))
# tmp <- predict(mod.dd.bins.stock, pred.dd.stock.bins, type = 'response', se.fit = TRUE) 
# pred.dd.stock.bins$lam.no.fish   <- exp(tmp$fit)
# pred.dd.stock.bins$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.stock.bins$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# # Now to do fun things I need the meta data on the pred dataframe
# pred.dd.stock.bins <- left_join(pred.dd.stock.bins,meta.sub,by="Stock.short")
# # Now a problem here is that this includes estimates for bins in which we don't have data.
# # So we do want to get rid of those
# real.bins <- unique(paste(dd.dat$Stock.short,"_",dd.dat$prop.bin))
# # All the bins in the predict object with same names same name...
# pred.dd.stock.bins$bin.combos <- paste(pred.dd.stock.bins$Stock.short,"_",pred.dd.stock.bins$prop.bin)
# # Now toss all the predicted bins without data.
# pred.dd.stock.bins <- pred.dd.stock.bins |> collapse::fsubset(bin.combos %in% real.bins)
# 
# # By region
# cols.1 <- rep(c("black","blue","orange",'firebrick2','lightgreen'),6)
# #col.try <- rep(c(rep("black",3),rep("blue",3),rep('orange',3),rep('firebrick2',3),rep('lightgreen',3)),20)
# pty.1 <- c(rep(0,5),rep(1,5),rep(2,5),rep(3,5),rep(4,5),rep(5,5))
# ggplot(pred.dd.stock.bins,aes(x=prop.bin,y=lam.no.fish,group=Stock.short,color=G.Species)) + 
#                                 geom_point(aes(shape=G.Species),size=2) + geom_line()  + xlab("Proportion of maximum abundance") + 
#                                 scale_y_log10(name = "Lambda",breaks = log_breaks(n=8)) +
#                                 facet_wrap(~Area.long)  +
#                                 scale_shape_manual(values=pty.1) +
#                                 scale_color_manual(values = cols.1) + 
#                                 geom_hline(yintercept = 1,color='grey',linetype = 'dashed')+
#                                 theme(legend.text=element_text(size=8),
#                                       legend.spacing.y = unit(-0.1, 'cm'),
#                                       legend.title = element_blank(),
#                                       axis.text.x = element_text(size=7)) + 
#                                  guides(color = guide_legend(ncol=1,byrow=T),
#                                         shape = guide_legend(ncol=1,byrow=T))
# 
# # By Species
# ggplot(pred.dd.stock.bins,aes(x=prop.bin,y=lam.no.fish,group=Stock.short,color=Area.long)) + 
#                                 geom_point(aes(shape=Area.long)) + geom_line()  + xlab("Proportion of maximum abundance") + 
#                                 scale_y_log10(name = "Lambda",breaks = log_breaks(n=8)) +
#                                 facet_wrap(~Order)  +
#                                 scale_shape_manual(values=pty.1) +
#                                 scale_color_manual(values = cols.1) + 
#                                 geom_hline(yintercept = 1,color='grey',linetype = 'dashed')+
#                                 theme(legend.text=element_text(size=8),
#                                       legend.spacing.y = unit(-0.1, 'cm'),
#                                       legend.title = element_blank(),
#                                       axis.text.x = element_text(size=7)) + 
#                                  guides(color = guide_legend(ncol=1,byrow=T),
#                                         shape = guide_legend(ncol=1,byrow=T))
# 
# # No fish vs fish lambda, note that DD is weaker when we account for fishing, that seems a fun result to talk about!
# 
# mod.dd.overall.gam.nf <- lm(log(lam.no.fish) ~ (prop.abund),data=dd.dat)
# mod.dd.overall.gam.fish <- lm(log(lam.fish) ~ (prop.abund),data=dd.dat)
# 
# 
# pred.dd.overall.bins.nf <- data.frame(prop.abund = seq(0,1,length.out=500),group = "F = 0")
# pred.dd.overall.bins.fish <- data.frame(prop.abund = seq(0,1,length.out=500),group = "F > 0")
# tmp <- predict(mod.dd.overall.gam.nf, pred.dd.overall.bins, type = 'response', se.fit = TRUE) 
# tmp.fish <- predict(mod.dd.overall.gam.fish, pred.dd.overall.bins, type = 'response', se.fit = TRUE) 
# pred.dd.overall.bins.nf$lam   <- exp(tmp$fit)
# pred.dd.overall.bins.nf$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.overall.bins.nf$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# 
# pred.dd.overall.bins.fish$lam   <- exp(tmp.fish$fit)
# pred.dd.overall.bins.fish$lower <- exp(tmp.fish$fit - 1.96 * tmp.fish$se.fit)
# pred.dd.overall.bins.fish$upper <- exp(tmp.fish$fit + 1.96 * tmp.fish$se.fit)
# 
# pred.dd.overall <- rbind(pred.dd.overall.bins.fish,pred.dd.overall.bins.nf)
# 
# ggplot(pred.dd.overall,aes(y=lam,x=prop.abund,group=group,color=group)) + 
#                                                   geom_line(linewidth=2) + 
#                                                   geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2) + 
#                                                   geom_hline(yintercept=1,linetype='dashed') + 
#                                                   xlab("Proportion of Maximum Abundance") + ylab("Lambda")
# 
# # OK, so if we compare the 40-60 bin with the 80-100 bin we should see the lambda's in the 40-60 bin are higher...
# 
# res.40.60 <- pred.dd.stock.bins |> collapse::fsubset(prop.bin %in% c("40-60%"))
# names(res.40.60)[names(res.40.60) == 'lam.no.fish'] <- "lam.40.60"
# res.80.100 <- pred.dd.stock.bins |> collapse::fsubset(prop.bin %in% c("80-100%"))
# names(res.80.100)[names(res.80.100) == 'lam.no.fish'] <- "lam.80.100"
# 
# tst <- left_join(res.40.60,res.80.100, by = names(res.40.60)[c(2,6:26)])
# tst$diff <- tst$lam.40.60 - tst$lam.80.100
# 
# hist(tst$diff)
# 
# res.lt.10 <- pred.dd.stock.bins |> collapse::fsubset(prop.bin %in% c("< 10%"))
# names(res.lt.10)[names(res.lt.10) == 'lam.no.fish'] <- "lam.lt.10"
# 
# tst <- left_join(res.40.60,res.lt.10, by = names(res.40.60)[c(2,6:26)])
# tst$diff <- tst$lam.lt.10 - tst$lam.40.60
# 
# hist(tst$diff)
# 
# res.10.20 <- pred.dd.stock.bins |> collapse::fsubset(prop.bin %in% c("10-20%"))
# names(res.10.20)[names(res.10.20) == 'lam.no.fish'] <- "lam.10.20"
# 
# tst <- left_join(res.40.60,res.10.20, by = names(res.40.60)[c(2,6:26)])
# tst$diff <- tst$lam.10.20 - tst$lam.40.60
# 
# hist(tst$diff)
# 
# 
# res.20.30 <- pred.dd.stock.bins |> collapse::fsubset(prop.bin %in% c("20-30%"))
# names(res.20.30)[names(res.20.30) == 'lam.no.fish'] <- "lam.20.30"
# 
# tst <- left_join(res.40.60,res.20.30, by = names(res.40.60)[c(2,6:26)])
# tst$diff <- tst$lam.20.30 - tst$lam.40.60
# 
# hist(tst$diff)
# 
# res.30.40 <- pred.dd.stock.bins |> collapse::fsubset(prop.bin %in% c("30-40%"))
# names(res.30.40)[names(res.30.40) == 'lam.no.fish'] <- "lam.30.40"
# 
# tst <- left_join(res.40.60,res.30.40, by = names(res.40.60)[c(2,6:26)])
# tst$diff <- tst$lam.30.40 - tst$lam.40.60
# 
# hist(tst$diff)


# 
# 
# dd.dat.no.bigs <- dd.dat |> collapse::fsubset(lam.no.fish < 2)
# dd.dat.six.no.bigs <- dd.dat.six |> collapse::fsubset(lam.no.fish < 2)
# just.bigs <- dd.dat  |> collapse::fsubset(lam.no.fish > 2) 
# sum(table(just.bigs$Stock.short)) # 48 of 68 are Haddock or cod. 13 of remaining 20 are small low trophic species
# 
# dd.dat$lam.ratio <- dd.dat$lam.org.no.fish/dd.dat$lam.no.fish
# dd.dat$lam.ratio.z <- dd.dat$lam.org.fish/dd.dat$lam.fish
# So the original lambda tended to be somewhere between 7 and 14% higher, depending on me(di)an choice.
# Could be way off in some years for a few species (Haddock, Cod, Sand lance, horse makerel, pilchard(sardine)... interesting... )
# summary(dd.dat$lam.ratio)
# summary(dd.dat$lam.ratio.z)
# ggplot(dd.dat,aes(y=lam.ratio,x=Species)) + geom_violin() + scale_y_log10() + geom_hline(yintercept =1) + theme_few(base_size=9)
# ggplot(dd.dat,aes(y=lam.ratio.z,x=Species)) + geom_violin() + scale_y_log10() + geom_hline(yintercept =1) + theme_few(base_size=9)



# Playing around to look at explanations for what we see, looked by LME, low and high stocks, but no smoking guns!
# low.stocks <- unique(dd.dat$Stock.short[dd.dat$prop.abund <= 0.1])
# dd.lows <- dd.dat |> collapse::fsubset(Stock.short %in% low.stocks)
# dd.highs <- dd.dat |> collapse::fsubset(!Stock.short %in% low.stocks)
# mod.dd.stock.gam.lows <- gam(log(lam.no.fish) ~ s(prop.abund,k=4) + s(prop.abund,by=as.factor(Stock.short),k=3),data=dd.lows )
# mod.dd.stock.gam.highs <- gam(log(lam.no.fish) ~ s(prop.abund,k=4) + s(prop.abund,by=as.factor(Stock.short),k=3),data=dd.highs )
# 
# pred.dd.stock.gam.tst <- expand.grid(prop.abund = seq(0, 1, length.out = 50),
#                                          Stock.short = c("Overall",unique(dd.highs$Stock.short)))
# 
# tmp <- predict(mod.dd.stock.gam.highs, pred.dd.stock.gam.tst, type = 'response', se.fit = TRUE) 
# pred.dd.stock.gam.tst$lam.no.fish   <- exp(tmp$fit)
# pred.dd.stock.gam.tst$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.stock.gam.tst$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# 
# ggplot(pred.dd.stock.gam.tst |> collapse::fsubset(Stock.short=='Overall'), aes(x=prop.abund,y=lam.no.fish)) + 
#                                 geom_point(data = hmm,aes(x=prop.abund,y=lam.no.fish),size=2,alpha=0.1) +  
#                                 geom_line(color='blue',linewidth=2) + 
#                                 xlab("Proportion of maximum abundance") + 
#                                 scale_y_log10(name = "Lambda",breaks = log_breaks(n=8)) +
#                                 geom_hline(yintercept = 1,color='grey',linetype = 'dashed')+
#                                 theme(legend.text=element_text(size=8),
#                                       legend.spacing.y = unit(-0.1, 'cm'),
#                                       legend.title = element_blank(),
#                                       axis.text.x = element_text(size=7)) + 
#                                  guides(color = guide_legend(ncol=1,byrow=T),
#                                         shape = guide_legend(ncol=1,byrow=T))
# 
# 
# ggplot(pred.dd.stock.gam.tst,aes(x=prop.abund,y=lam.no.fish,group=Stock.short,color=Stock.short,shape=Stock.short)) + 
#                                 geom_line() + 
#                                 #geom_point(data = thin.pred,size=2) +  
#                                 xlab("Proportion of maximum abundance") + 
#                                 scale_y_log10(name = "Lambda",breaks = log_breaks(n=8)) +
#                                 #facet_wrap(~Area.long)  +
#                                 #scale_shape_manual(values=pty.gam) +
#                                 #scale_color_manual(values = cols.gam) + 
#                                 geom_hline(yintercept = 1,color='grey',linetype = 'dashed')+
#                                 theme(legend.text=element_text(size=8),
#                                       legend.spacing.y = unit(-0.1, 'cm'),
#                                       legend.title = element_blank(),
#                                       axis.text.x = element_text(size=7)) + 
#                                  guides(color = guide_legend(ncol=1,byrow=T),
#                                         shape = guide_legend(ncol=1,byrow=T))

# Is there any density dependence in fishing mortality??
# dd.dat$mu <- dd.dat$removals/dd.dat$vpa.abund
# dd.dat$fm <- -log(1-dd.dat$mu)
# 
# ggplot(dd.dat , aes(x=prop.abund,y=fm)) + 
#                                 geom_point() + 
#                                 geom_smooth(method = 'gam') + 
#                                 scale_x_continuous(name="Proportion of Maximum Abundance") +
#                                 scale_y__continuous(name = "Fishing Mortality (instantaneous)")
# 
# 
# qqnorm(log(dd.dat$mu))
# qqline(log(dd.dat$mu))
# hist(log(dd.dat$mu))
# 
# fm.mod <- lm(log(fm)~prop.abund,data=dd.dat)
# par(mfrow=c(2,2))
# plot(fm.mod)
# par(mfrow=c(1,1))

# windows(11,11)
# col.try <- rep(rep(c("black","blue","orange",'firebrick2','lightgreen'),3),20)
# pty <- rep(c(rep(21,5),rep(22,5),rep(23,5)),20)

# 
# r0.ts.plt <- ggplot(pop.dam.6,aes(y=R0.opt,x=cohort,group=Stock.short,color=Stock.short,shape = Stock.short,fill = Stock.short)) + 
#                             geom_line(size=2)  + geom_point(size=4) +
#                             scale_y_log10(name = "Lifetime Reproductive Output") +
#                             facet_wrap(~G.Species) +
#                             scale_color_manual(name = "Stock",values = col.try) + scale_shape_manual(name = "Stock",values = pty) +
#                             scale_fill_manual(name = "Stock",values = col.try)+
#                             guides(colour = guide_legend(ncol = 1))+
#                             theme(axis.text.x = element_text(angle =45,hjust=1),legend.key.width = unit(5,'cm')) 
# r0.ts.plt
# 
# save_plot("D:/Github/ICM/Figures/tuned/R0_timeseries_6.png",r0.ts.plt,base_width = 30,base_height = 12)
# 
# r0.boxplt <- ggplot(pop.dam) + geom_boxplot(aes(y=R0.opt,x=Stock.no.species))  + 
#                             scale_y_log10(name = "Lifetime Reproductive Output")+#, breaks = c(0.001,0.01,0.1,1,5,10,50,100),minor_breaks = NULL) + 
#                             facet_wrap(~G.Species,scales = 'free')+
#                             theme(axis.text.x = element_text(angle =45,hjust=1),legend.position = 'none')
# r0.boxplt



# 
# windows(11,11)
# ggplot(pop.dam) + geom_boxplot(aes(y=gen.len.opt,x=Species)) + facet_wrap(~LME,scales='free_x') +
#                   ylab("Generation Length (years)") + theme(axis.text.x = element_text(angle =45,hjust=1))
# 
# windows(11,11)
# col.try <- rep(rep(c("black","blue","orange",'firebrick2','lightgreen'),3),20)
# lty <- rep(c(rep(1,5),rep(2,5),rep(4,5)),20)
# 
# gen.ts.plt <- ggplot(pop.dam.6,aes(y=gen.len.opt,x=cohort,group=Stock.short,color=Stock.short,linetype = Stock.short)) + 
#                             geom_line(size=2)  + 
#                             scale_y_log10(name = "Generation Length") +
#                             facet_wrap(~G.Species) +
#                             scale_color_manual(name = "Stock",values = col.try) + scale_linetype_manual(name = "Stock",values = lty) +
#                             guides(colour = guide_legend(ncol = 1))+
#                             theme(axis.text.x = element_text(angle =45,hjust=1),legend.key.width = unit(5,'cm')) 
# gen.ts.plt
# save_plot("D:/Github/ICM/Figures/tuned/Gen_time_series_6.png",gen.ts.plt,base_width = 20,base_height = 12)

# 
# ggplot(for.tunes) + geom_jitter(aes(y=lambda,x=Species,group=Stock.short,color=Stock.short)) + 
#                     scale_y_continuous(name = 'rate of growth (lambda)',breaks = c(-1,-0.5,0,0.5,1:10)) +
#                             theme(axis.text.x = element_text(angle =45,hjust=1))
# 
# ggplot(for.tunes) + geom_jitter(aes(y=lambda.vpa.init,x=Species)) + scale_y_continuous(name = 'rate of growth (lambda)',breaks = c(-1,-0.5,0,0.5,1:10),limits = c(-1,3))
# 
# unique(for.tunes$Species)
# windows(11,11)
# 
# ggplot(for.tunes) + geom_density(aes(lambda,group=Species,color=Species,fill=Species),alpha = 0.2) + scale_x_continuous(breaks = c(0,0.5,1,2,5,10))
# 
# 
# #options(scipen=999)
# r0.plt <- ggplot(pop.dam) + geom_boxplot(aes(y=R0.opt,x=Area))  + 
#                             scale_y_log10(name = "Lifetime Reproductive Output")+#, breaks = c(0.001,0.01,0.05,0.1,0.5,1,5,10,50,100),minor_breaks = NULL) + 
#                             facet_wrap(~Species,scales = 'free')+
#                             theme(axis.text.x = element_text(angle =45,hjust=1))
# save_plot("D:/Github/ICM/Figures/tuned/R0_ignoring_fishing.png",r0.plt,base_width = 8,base_height = 8)
# 
# 
# 
# vickis.cols <- sort(rep(c( "#172582",  "#F8DC91", "#FBB891", "#FB6A01", "#B80000"),3))
# linetypes <- rep(c(1,2,4),5)
# 
# windows(11,11)
# cod.r0.ts.plt <- ggplot(pop.dam |> collapse::fsubset(Species == 'morhua')) + geom_line(aes(y=R0.opt,x=cohort,group=Area,color=Area,linetype=Area),size=1.5)  + 
#                             scale_y_log10(name = "Lifetime Reproductive Output", breaks = c(0.001,0.01,0.1,1,5,10,50,100),minor_breaks = NULL) + 
#                             scale_color_manual(values = vickis.cols) +
#                             scale_linetype_manual(values = linetypes) +
#                             theme(legend.key.width  = unit(2, "cm"))
# cod.r0.ts.plt
# #save_plot("D:/Github/ICM/Figures/tuned/R0_timeseries_ignoring_fishing.png",r0.plt,base_width = 8,base_height = 8)
# 
# 
# windows(11,11)
# ggplot(pop.dam |> collapse::fsubset(Species =="morhua")) + geom_boxplot(aes(y=R0.opt,x=Area))  + 
#                                                         scale_y_log10(name = "Lifetime Reproductive Output",breaks = c(0.001,0.01,0.1,1,5,10,50,100),minor_breaks = NULL) +
#                                                         theme(axis.text.x = element_text(angle =45,hjust=1))
# 
# # Missing catch questions
# # first did we do much to the Fecundity term to get here
# quantile(for.tunes$mean.fec/for.tunes$mean.vpa.fec,probs=seq(0.01,1,0.01),na.rm=T)
# 
# quantile((for.tunes$removals-for.tunes$removals.init)/for.tunes$removals.init,probs=seq(0.01,1,0.01),na.rm=T)
# quantile((for.tunes$mean.nm-for.tunes$mean.vpa.nm)/for.tunes$mean.vpa.nm,probs=seq(0.01,1,0.01),na.rm=T)
# 
# for.tunes$excess.catch <- for.tunes$removals-for.tunes$removals.init
# for.tunes$per.excess.catch <- 100*((for.tunes$removals-for.tunes$removals.init)/for.tunes$removals.init)
# 
# windows(11,11)
# bycatch.plt <- ggplot(for.tunes) + geom_boxplot(aes(y=per.excess.catch,x=Species)) + 
#                                    ylab("Adjustment to catch (%)") +
#                                    theme(axis.text.x = element_text(angle=45,hjust = 1))
#                                    
# save_plot("D:/Github/ICM/Figures/tuned/Percentage_change_to_bycatch_by_species.png",bycatch.plt,base_width = 8,base_height = 8)
#                                    
# bycatch.plt.cod <- ggplot(for.tunes |> collapse::fsubset(Species == 'morhua')) + geom_boxplot(aes(y=per.excess.catch,x=Area)) + 
#                                                                               ylab("Adjustment to catch (%)") +
#                                                                               theme(axis.text.x = element_text(angle=45,hjust = 1))
#                                                                               
# save_plot("D:/Github/ICM/Figures/tuned/Percentage_change_to_bycatch_by_cod_stock.png",bycatch.plt.cod,base_width = 8,base_height = 8)
# 
# # bycatch.plt <- ggplot(for.tunes) + geom_boxplot(aes(y=per.excess.catch,x=Area)) + facet_wrap(~Species,scales = 'free_x')
# #                                    ylab("Adjustment to catch (%)") +
# #                                    theme(axis.text.x = element_text(angle=45,hjust = 1))
# # bycatch.plt                                   
#                        

# Doubling time for the rest of the stocks...

# dub.heatmap.no.6 <- ggplot(dub.time.summary |> collapse::fsubset(!Species %in% six.species), aes(x=year, y=Stock.short, fill= prop)) + 
#                               xlab("") + ylab("")+                                    
#                               #facet_wrap(~G.Species,nrow=3,scales='free_y',strip.position = "right") + 
#                               scale_x_continuous() +
#                               geom_tile() + scale_fill_viridis(name = "Proportion",discrete=FALSE) + 
#                               theme(legend.position = 'none',text = element_text(size=12),plot.margin = margin(0,0.5,0,0.68, "cm"))
```






<!-- Here are the models that we ran but didn't end up using# -->
<!-- Here are the models that we ran but didn't end up using# -->
<!-- Here are the models that we ran but didn't end up using# -->
<!-- Here are the models that we ran but didn't end up using# -->
<!-- Here are the models that we ran but didn't end up using# -->
<!-- Here are the models that we ran but didn't end up using# -->
<!-- Here are the models that we ran but didn't end up using# -->



```{r failed-models}

# A density dependence model, start simple and build...
# mod.dd.base <- lm(log(lam.no.fish) ~ prop.abund,data=dd.dat)
# summary(mod.dd.base)
# 
# mod.dd.base.fish <- lm(log(lam.fish) ~ prop.abund,data=dd.dat)
# summary(mod.dd.base.fish)
# #ggplot(dd.dat, aes(y = lam.no.fish,x=prop.abund)) + geom_point() + geom_smooth(method = 'lm') + scale_y_log10() + geom_hline(yintercept = 1,color='firebrick2',linetype='dashed',linewidth=2)
# 
# 
# # Residuals are nowhere near normal, the fit isn't a disaster but def have the old trumpet shape happening
# par(mfrow=c(2,2))
# plot(mod.dd.base)
# par(mfrow=c(1,1))
# # This mostly represents the above model...
# ggplot(dd.dat, aes(y = lam.no.fish,x=prop.abund)) + 
#                   geom_point() + 
#                   geom_smooth(method = 'lm') + scale_y_log10() +
#                   geom_hline(yintercept = 1,color='firebrick2',linetype='dashed',linewidth=2)
# # What happens with a gam?
# mod.dd.gam.base <- gam(log(lam.no.fish) ~ s(prop.abund),data=dd.dat)
# summary(mod.dd.gam.base)
# # Still see that the residuals are higher at low values
# plot(residuals(mod.dd.gam.base) ~ dd.dat$prop.abund)
# # not great...
# plot(residuals(mod.dd.gam.base) ~ fitted(mod.dd.gam.base))
# # What's the fit look like?
# pred.dd.gam.base <- data.frame(prop.abund = seq(0, 1, length.out = 1000))
# tmp <- predict(mod.dd.gam.base, dd.gam.base.pred, type = 'response', se.fit = TRUE) 
# 
# pred.dd.gam.base$lam.no.fish   <- exp(tmp$fit)
# pred.dd.gam.base$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.gam.base$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# 
# # So here's the game fit, I thnk it does do an ok job of showing that no much is happening below maybe 0.3, but then
# # below 0.15 it starts increasing, suggesting general compensation, but we know the really high values matter here and are
# # limited to a subset of the stocks, anywho we know the residuals suck, so moving on...
# ggplot(dd.dat,aes(y=lam.no.fish,x=prop.abund)) + 
#                   geom_point() + scale_y_log10() +
#                   geom_ribbon(data=pred.dd.gam.base,aes(ymin=lower,ymax=upper,x=prop.abund),alpha=0.4) +
#                   geom_line(data = pred.dd.gam.base,aes(y=lam.no.fish, x= prop.abund))
#     
# 
# # What if we did a glm, Gamma with log-link seems a natural thing to try...
# mod.dd.glm.gamma <- glm(lam.no.fish ~ prop.abund,data=dd.dat,family = Gamma(link='log'))
# # What's that done...
# summary(mod.dd.glm.gamma)
# # Still some pretty gross shit going on here...
# par(mfrow=c(2,2))
# plot(mod.dd.glm.gamma)
# par(mfrow=c(1,1))
# # Now plot it...
# pred.dd.glm.base <- data.frame(prop.abund = seq(0, 1, length.out = 1000))
# tmp <- predict(mod.dd.glm.gamma, dd.gam.base.pred, type = 'response', se.fit = TRUE) 
# 
# pred.dd.glm.base$lam.no.fish   <- (tmp$fit)
# pred.dd.glm.base$lower <- (tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.glm.base$upper <- (tmp$fit + 1.96 * tmp$se.fit)
# # Pretty similar, though I think on the linear scale we see the 'rate' may be decreasing as we approach 0
# # But still not a good model given the above
# ggplot(dd.dat,aes(y=lam.no.fish,x=prop.abund)) + 
#                   geom_point() + scale_y_log10() +
#                   geom_ribbon(data=pred.dd.glm.base,aes(ymin=lower,ymax=upper,x=prop.abund),alpha=0.4) +
#                   geom_line(data = pred.dd.glm.base,aes(y=lam.no.fish, x= prop.abund))
#     
# # Now what if we account for species in these and get an estimate for each species. 
# # I think this should be done as a random effect, we'll start with linear mixed models and see what happens...
# 
# mod.dd.species.re <- lmer(log(lam.no.fish) ~ prop.abund + (1| Species),data=dd.dat)
# # So that seems reasonable...
# summary(mod.dd.species.re)
# #Residuals are still pretty cranky
# plot(mod.dd.species.re)
# # Normality still a hot mess
# qqnorm(residuals(mod.dd.species.re))
# qqline(residuals(mod.dd.species.re))
# # draw some lines...
# pred.dd.lmm.species <- expand.grid(prop.abund = seq(0, 1, length.out = 100),Species=unique(dd.dat$Species))
# tmp <- predict(mod.dd.species.re, pred.dd.lmm.species, type = 'response', se.fit = TRUE) 
# pred.dd.lmm.species$lam.no.fish   <- exp(tmp$fit)
# pred.dd.lmm.species$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.lmm.species$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# # Here are the fits (sans SE cause messy + didn't put the overall relationship on here)
# ggplot(pred.dd.lmm.species,aes(x=prop.abund,y=lam.no.fish,group=Species,color=Species)) + 
#                                 geom_line()  + 
#                                 geom_point(data=dd.dat,aes(x=prop.abund,y=lam.no.fish,group=Species, color=Species)) +
#                                 scale_y_log10()
# 
# # We could also allow the slope to vary by species, might get a bit better, but really won't do the trick...
# mod.dd.species.slope.re <- lmer(log(lam.no.fish) ~ prop.abund + (1+ prop.abund| Species),data=dd.dat)
# summary(mod.dd.species.slope.re)
# #Residuals are still pretty cranky
# plot(mod.dd.species.slope.re)
# # Normality still a hot mess
# qqnorm(residuals(mod.dd.species.slope.re))
# qqline(residuals(mod.dd.species.slope.re))
# # draw some lines...
# pred.dd.lmm.species.slope <- expand.grid(prop.abund = seq(0, 1, length.out = 100),Species=unique(dd.dat$Species))
# tmp <- predict(mod.dd.species.slope.re, pred.dd.lmm.species.slope, type = 'response', se.fit = TRUE) 
# pred.dd.lmm.species.slope$lam.no.fish   <- exp(tmp$fit)
# pred.dd.lmm.species.slope$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.lmm.species.slope$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# # Here are the fits (sans SE cause messy + didn't put the overall relationship on here)
# ggplot(pred.dd.lmm.species.slope,aes(x=prop.abund,y=lam.no.fish,group=Species,color=Species)) + 
#                                 geom_line()  + 
#                                 geom_point(data=dd.dat,aes(x=prop.abund,y=lam.no.fish,group=Species, color=Species)) +
#                                 scale_y_log10()
# # Curious what species have high slopes.. Dubious and Esmarkii (North Sea sand lance and mackerel)
# ranef(mod.dd.species.slope.re)
# 
# # So so what if we let the slopes vary by stock
# mod.dd.stock.re <- lmer(log(lam.no.fish) ~ prop.abund +  (1+ prop.abund | Stock.short),data=dd.dat)
# summary(mod.dd.stock.re)
# #Residuals are slightly better I think but still really suck
# plot(mod.dd.stock.re)
# # Normality = no
# qqnorm(residuals(mod.dd.stock.re))
# qqline(residuals(mod.dd.stock.re))
# # What's it look like?
# pred.dd.lmm.stock <- expand.grid(prop.abund = seq(0, 1, length.out = 100),
#                                          #Species=unique(dd.dat$Species),
#                                          Stock.short=unique(dd.dat$Stock.short))
# tmp <- predict(mod.dd.stock.re, pred.dd.lmm.stock, type = 'response', se.fit = TRUE) 
# pred.dd.lmm.stock$lam.no.fish   <- exp(tmp$fit)
# pred.dd.lmm.stock$lower <- exp(tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.lmm.stock$upper <- exp(tmp$fit + 1.96 * tmp$se.fit)
# # Here are the fits (sans SE cause messy + didn't put the overall relationship on here)
# ggplot(pred.dd.lmm.stock,aes(x=prop.abund,y=lam.no.fish,group=Stock.short,color=Stock.short)) + 
#                                 geom_line()  + 
#                                 geom_point(data=dd.dat,aes(x=prop.abund,y=lam.no.fish,group=Stock.short, color=Stock.short)) +
#                                 scale_y_log10()
# 
# # Curious what stocks have high slopes.. Dubious and Esmarkii (North Sea sand lance and mackerel), NS Haddock and Irish Sea Haddock 
# ranef(mod.dd.stock.re)
# 
# 
# 
# 
# # OK, so this all still sucks, wonder if a glmer and gamma would get us anywhere... not really.... 
# # Tried many variants on the glmer and they all land in the same lousy spot.
# mod.dd.stock.gamma.re <- glmer(lam.no.fish ~ prop.abund +  (1+ prop.abund | Stock.short),data=dd.dat,family=Gamma(link='log'))
# # OK...
# summary(mod.dd.stock.gamma.re)
# #Residuals, nah, still suck, just some crazy outliers...
# plot(mod.dd.stock.gamma.re)
# # Normality = no
# qqnorm(residuals(mod.dd.stock.gamma.re))
# qqline(residuals(mod.dd.stock.gamma.re))
# # And the plot...
# pred.dd.lmm.stock.gamma <- expand.grid(prop.abund = seq(0, 1, length.out = 100),
#                                          #Species=unique(dd.dat$Species),
#                                          Stock.short=unique(dd.dat$Stock.short))
# tmp <- predict(mod.dd.stock.gamma.re, pred.dd.lmm.stock.gamma, type = 'response', se.fit = TRUE) 
# pred.dd.lmm.stock.gamma$lam.no.fish   <- (tmp$fit)
# pred.dd.lmm.stock.gamma$lower <- (tmp$fit - 1.96 * tmp$se.fit)
# pred.dd.lmm.stock.gamma$upper <- (tmp$fit + 1.96 * tmp$se.fit)
# # Here are the fits (sans SE cause messy + didn't put the overall relationship on here)
# ggplot(pred.dd.lmm.stock.gamma,aes(x=prop.abund,y=lam.no.fish,group=Stock.short,color=Stock.short)) + 
#                                 geom_line()  + 
#                                 geom_point(data=dd.dat,aes(x=prop.abund,y=lam.no.fish,group=Stock.short, color=Stock.short)) +
#                                 scale_y_log10()
# # None of the above really work at all....

```